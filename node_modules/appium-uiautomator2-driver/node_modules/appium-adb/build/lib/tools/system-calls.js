"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DEFAULT_ADB_EXEC_TIMEOUT", {
  enumerable: true,
  get: function () {
    return _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  }
});
exports.default = void 0;
exports.getAndroidBinaryPath = getAndroidBinaryPath;
require("source-map-support/register");
var _path = _interopRequireDefault(require("path"));
var _logger = _interopRequireDefault(require("../logger.js"));
var _bluebird = _interopRequireDefault(require("bluebird"));
var _support = require("@appium/support");
var _helpers = require("../helpers");
var _teen_process = require("teen_process");
var _asyncbox = require("asyncbox");
var _lodash = _interopRequireDefault(require("lodash"));
var _semver = _interopRequireDefault(require("semver"));
let systemCallMethods = {};
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const ADB_RETRY_ERROR_PATTERNS = [/protocol fault \(no status\)/i, /error: device ('.+' )?not found/i, /error: device still connecting/i];
const BINARY_VERSION_PATTERN = /^Version ([\d.]+)-(\d+)/m;
const BRIDGE_VERSION_PATTERN = /^Android Debug Bridge version ([\d.]+)/m;
const CERTS_ROOT = '/system/etc/security/cacerts';
const SDK_BINARY_ROOTS = ['platform-tools', 'emulator', ['cmdline-tools', 'latest', 'bin'], 'tools', ['tools', 'bin'], '.'];
const MIN_DELAY_ADB_API_LEVEL = 28;
const REQUIRED_SERVICES = ['activity', 'package', 'mount'];
const SUBSYSTEM_STATE_OK = 'Subsystem state: true';
systemCallMethods.getSdkBinaryPath = async function getSdkBinaryPath(binaryName) {
  return await this.getBinaryFromSdkRoot(binaryName);
};
systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function getBinaryNameForOSMemorize(binaryName) {
  return getBinaryNameForOS(binaryName);
});
function getBinaryNameForOS(binaryName) {
  if (!_support.system.isWindows()) {
    return binaryName;
  }
  if (['android', 'apksigner', 'apkanalyzer'].includes(binaryName)) {
    return `${binaryName}.bat`;
  }
  if (!_path.default.extname(binaryName)) {
    return `${binaryName}.exe`;
  }
  return binaryName;
}
systemCallMethods.getBinaryFromSdkRoot = async function getBinaryFromSdkRoot(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }
  const fullBinaryName = this.getBinaryNameForOS(binaryName);
  const binaryLocs = getSdkBinaryLocationCandidates(this.sdkRoot, fullBinaryName);
  let buildToolsDirs = await (0, _helpers.getBuildToolsDirs)(this.sdkRoot);
  if (this.buildToolsVersion) {
    buildToolsDirs = buildToolsDirs.filter(x => _path.default.basename(x) === this.buildToolsVersion);
    if (_lodash.default.isEmpty(buildToolsDirs)) {
      _logger.default.info(`Found no build tools whose version matches to '${this.buildToolsVersion}'`);
    } else {
      _logger.default.info(`Using build tools at '${buildToolsDirs}'`);
    }
  }
  binaryLocs.push(..._lodash.default.flatten(buildToolsDirs.map(dir => [_path.default.resolve(dir, fullBinaryName), _path.default.resolve(dir, 'lib', fullBinaryName)])));
  let binaryLoc = null;
  for (const loc of binaryLocs) {
    if (await _support.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }
  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` + `Do you have Android Build Tools ${this.buildToolsVersion ? `v ${this.buildToolsVersion} ` : ''}` + `installed at '${this.sdkRoot}'?`);
  }
  _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);
  this.binaries[binaryName] = binaryLoc;
  return binaryLoc;
};
function getSdkBinaryLocationCandidates(sdkRoot, fullBinaryName) {
  return SDK_BINARY_ROOTS.map(x => _path.default.resolve(sdkRoot, ...(_lodash.default.isArray(x) ? x : [x]), fullBinaryName));
}
async function getAndroidBinaryPath(binaryName) {
  const fullBinaryName = getBinaryNameForOS(binaryName);
  const sdkRoot = (0, _helpers.getSdkRootFromEnv)();
  const binaryLocs = getSdkBinaryLocationCandidates(sdkRoot, fullBinaryName);
  for (const loc of binaryLocs) {
    if (await _support.fs.exists(loc)) {
      return loc;
    }
  }
  throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` + `Do you have Android Build Tools installed at '${sdkRoot}'?`);
}
systemCallMethods.getBinaryFromPath = async function getBinaryFromPath(binaryName) {
  if (this.binaries[binaryName]) {
    return this.binaries[binaryName];
  }
  const fullBinaryName = this.getBinaryNameForOS(binaryName);
  try {
    const binaryLoc = await _support.fs.which(fullBinaryName);
    _logger.default.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);
    this.binaries[binaryName] = binaryLoc;
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find '${fullBinaryName}' in PATH. Please set the ANDROID_HOME ` + `or ANDROID_SDK_ROOT environment variables to the correct Android SDK root directory path.`);
  }
};
systemCallMethods.getConnectedDevices = async function getConnectedDevices(opts = {}) {
  _logger.default.debug('Getting connected devices');
  const args = [...this.executable.defaultArgs, 'devices'];
  if (opts.verbose) {
    args.push('-l');
  }
  let stdout;
  try {
    ({
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, args));
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }
  const listHeader = 'List of devices';
  const startingIndex = stdout.indexOf(listHeader);
  if (startingIndex < 0) {
    throw new Error(`Unexpected output while trying to get devices: ${stdout}`);
  }
  stdout = stdout.slice(startingIndex);
  let excludedLines = [listHeader, 'adb server', '* daemon'];
  if (!this.allowOfflineDevices) {
    excludedLines.push('offline');
  }
  const devices = stdout.split('\n').map(_lodash.default.trim).filter(line => line && !excludedLines.some(x => line.includes(x))).map(line => {
    const [udid, state, ...description] = line.split(/\s+/);
    const device = {
      udid,
      state
    };
    if (opts.verbose) {
      for (const entry of description) {
        if (entry.includes(':')) {
          const [key, value] = entry.split(':');
          device[key] = value;
        }
      }
    }
    return device;
  });
  if (_lodash.default.isEmpty(devices)) {
    _logger.default.debug('No connected devices have been detected');
  } else {
    _logger.default.debug(`Connected devices: ${JSON.stringify(devices)}`);
  }
  return devices;
};
systemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry(timeoutMs = 20000) {
  const timer = new _support.timing.Timer().start();
  _logger.default.debug('Trying to find a connected android device');
  const getDevices = async () => {
    if (timer.getDuration().asMilliSeconds > timeoutMs) {
      throw new Error(`Could not find a connected Android device in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms.`);
    }
    try {
      const devices = await this.getConnectedDevices();
      if (devices.length > 0) {
        return devices;
      }
    } catch (ign) {}
    _logger.default.debug('Could not find online devices');
    try {
      await this.reconnect();
    } catch (ign) {
      await this.restartAdb();
    }
    await (0, _asyncbox.sleep)(200);
    return await getDevices();
  };
  return await getDevices();
};
systemCallMethods.reconnect = async function reconnect(target = 'offline') {
  _logger.default.debug(`Reconnecting adb (target ${target})`);
  const args = ['reconnect'];
  if (target) {
    args.push(target);
  }
  try {
    await this.adbExec(args);
  } catch (e) {
    throw new Error(`Cannot reconnect adb. Original error: ${e.stderr || e.message}`);
  }
};
systemCallMethods.restartAdb = async function restartAdb() {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);
    return;
  }
  _logger.default.debug('Restarting adb');
  try {
    await this.killServer();
    await this.adbExec(['start-server']);
  } catch (e) {
    _logger.default.error(`Error killing ADB server, going to see if it's online anyway`);
  }
};
systemCallMethods.killServer = async function killServer() {
  _logger.default.debug(`Killing adb server on port '${this.adbPort}'`);
  await this.adbExec(['kill-server'], {
    exclusive: true
  });
};
systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function resetTelnetAuthToken() {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);
    return false;
  }
  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');
  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);
  try {
    await _support.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);
    return false;
  }
  return true;
});
systemCallMethods.adbExecEmu = async function adbExecEmu(cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};
let isExecLocked = false;
systemCallMethods.EXEC_OUTPUT_FORMAT = Object.freeze({
  STDOUT: 'stdout',
  FULL: 'full'
});
systemCallMethods.adbExec = async function adbExec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }
  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.adbExecTimeout || _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout';
  const {
    outputFormat = this.EXEC_OUTPUT_FORMAT.STDOUT
  } = opts;
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;
  const execFunc = async () => {
    try {
      const args = [...this.executable.defaultArgs, ...cmd];
      _logger.default.debug(`Running '${this.executable.path} ` + (args.find(arg => /\s+/.test(arg)) ? _support.util.quote(args) : args.join(' ')) + `'`);
      let {
        stdout,
        stderr
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return outputFormat === this.EXEC_OUTPUT_FORMAT.FULL ? {
        stdout,
        stderr
      } : stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      if (ADB_RETRY_ERROR_PATTERNS.some(p => p.test(errText))) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);
        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();
        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }
      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }
      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Command output: ${e.stderr || e.stdout || '<empty>'}`;
      }
      throw e;
    }
  };
  if (isExecLocked) {
    _logger.default.debug('Waiting until the other exclusive ADB command is completed');
    await (0, _asyncbox.waitForCondition)(() => !isExecLocked, {
      waitMs: Number.MAX_SAFE_INTEGER,
      intervalMs: 10
    });
    _logger.default.debug('Continuing with the current ADB command');
  }
  if (opts.exclusive) {
    isExecLocked = true;
  }
  try {
    return await execFunc();
  } finally {
    if (opts.exclusive) {
      isExecLocked = false;
    }
  }
};
systemCallMethods.shell = async function shell(cmd, opts = {}) {
  const {
    privileged
  } = opts;
  const cmdArr = _lodash.default.isArray(cmd) ? cmd : [cmd];
  const fullCmd = ['shell'];
  if (privileged) {
    _logger.default.info(`'adb shell ${_support.util.quote(cmdArr)}' requires root access`);
    if (await this.isRoot()) {
      _logger.default.info('The device already had root access');
      fullCmd.push(...cmdArr);
    } else {
      fullCmd.push('su', 'root', _support.util.quote(cmdArr));
    }
  } else {
    fullCmd.push(...cmdArr);
  }
  return await this.adbExec(fullCmd, opts);
};
systemCallMethods.createSubProcess = function createSubProcess(args = []) {
  args = [...this.executable.defaultArgs, ...args];
  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);
  return new _teen_process.SubProcess(this.getAdbPath(), args);
};
systemCallMethods.getAdbServerPort = function getAdbServerPort() {
  return this.adbPort;
};
systemCallMethods.getEmulatorPort = async function getEmulatorPort() {
  _logger.default.debug('Getting running emulator port');
  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }
  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);
    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};
systemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString(emStr) {
  let portPattern = /emulator-(\d+)/;
  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }
  return false;
};
systemCallMethods.getConnectedEmulators = async function getConnectedEmulators(opts = {}) {
  _logger.default.debug('Getting connected emulators');
  try {
    let devices = await this.getConnectedDevices(opts);
    let emulators = [];
    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);
      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }
    _logger.default.debug(`${_support.util.pluralize('emulator', emulators.length, true)} connected`);
    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};
systemCallMethods.setEmulatorPort = function setEmulatorPort(emPort) {
  this.emulatorPort = emPort;
};
systemCallMethods.setDeviceId = function setDeviceId(deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);
  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');
  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }
  this.executable.defaultArgs.push('-s', deviceId);
};
systemCallMethods.setDevice = function setDevice(deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};
systemCallMethods.getRunningAVD = async function getRunningAVD(avdName) {
  _logger.default.debug(`Trying to find '${avdName}' emulator`);
  try {
    const emulators = await this.getConnectedEmulators();
    for (const emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      const runningAVDName = await this.execEmuConsoleCommand(['avd', 'name'], {
        port: emulator.port,
        execTimeout: 5000,
        connTimeout: 1000
      });
      if (_lodash.default.toLower(avdName) === _lodash.default.toLower(runningAVDName.trim())) {
        _logger.default.debug(`Found emulator '${avdName}' on port ${emulator.port}`);
        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }
    _logger.default.debug(`Emulator '${avdName}' not running`);
    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};
systemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry(avdName, timeoutMs = 20000) {
  try {
    return await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return await this.getRunningAVD(avdName.replace('@', ''));
      } catch (e) {
        _logger.default.debug(e.message);
        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }
};
systemCallMethods.killAllEmulators = async function killAllEmulators() {
  let cmd, args;
  if (_support.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }
  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};
systemCallMethods.killEmulator = async function killEmulator(avdName = null, timeout = 60000) {
  if (_support.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);
    const device = await this.getRunningAVD(avdName);
    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);
      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);
    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);
      return false;
    }
  }
  await this.adbExec(['emu', 'kill']);
  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _support.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}
      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }
  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);
  return true;
};
systemCallMethods.launchAVD = async function launchAVD(avdName, opts = {}) {
  const {
    args = [],
    env = {},
    language,
    country,
    launchTimeout = 60000,
    readyTimeout = 60000,
    retryTimes = 1
  } = opts;
  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${launchTimeout}ms and readyTimeout ${readyTimeout}ms`);
  const emulatorBinaryPath = await this.getSdkBinaryPath('emulator');
  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }
  await this.checkAvdExist(avdName);
  const launchArgs = ['-avd', avdName];
  launchArgs.push(...(0, _helpers.toAvdLocaleArgs)(language, country));
  let isDelayAdbFeatureEnabled = false;
  if (this.allowDelayAdb) {
    const {
      revision
    } = await this.getEmuVersionInfo();
    if (revision && _support.util.compareVersions(revision, '>=', '29.0.7')) {
      try {
        const {
          target
        } = await this.getEmuImageProperties(avdName);
        const apiMatch = /\d+/.exec(target);
        if (apiMatch && parseInt(apiMatch[0], 10) >= MIN_DELAY_ADB_API_LEVEL) {
          launchArgs.push('-delay-adb');
          isDelayAdbFeatureEnabled = true;
        } else {
          throw new Error(`The actual image API version is below ${MIN_DELAY_ADB_API_LEVEL}`);
        }
      } catch (e) {
        _logger.default.info(`The -delay-adb emulator startup detection feature will not be enabled. ` + `Original error: ${e.message}`);
      }
    }
  } else {
    _logger.default.info('The -delay-adb emulator startup detection feature has been explicitly disabled');
  }
  if (!_lodash.default.isEmpty(args)) {
    launchArgs.push(...(_lodash.default.isArray(args) ? args : _support.util.shellParse(`${args}`)));
  }
  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${_support.util.quote(launchArgs)}`);
  if (!_lodash.default.isEmpty(env)) {
    _logger.default.debug(`Customized emulator environment: ${JSON.stringify(env)}`);
  }
  const proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs, {
    env: Object.assign({}, process.env, env)
  });
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, launchTimeout));
  const timer = new _support.timing.Timer().start();
  if (isDelayAdbFeatureEnabled) {
    try {
      await this.adbExec(['wait-for-device'], {
        timeout: readyTimeout
      });
    } catch (e) {
      throw new Error(`'${avdName}' Emulator has failed to boot: ${e.stderr || e.message}`);
    }
  }
  await this.waitForEmulatorReady(readyTimeout - timer.getDuration().asMilliSeconds);
  return proc;
};
systemCallMethods.getVersion = _lodash.default.memoize(async function getVersion() {
  let stdout;
  try {
    stdout = await this.adbExec('version');
  } catch (e) {
    throw new Error(`Error getting adb version: ${e.stderr || e.message}`);
  }
  const result = {};
  const binaryVersionMatch = BINARY_VERSION_PATTERN.exec(stdout);
  if (binaryVersionMatch) {
    result.binary = {
      version: _semver.default.coerce(binaryVersionMatch[1]),
      build: parseInt(binaryVersionMatch[2], 10)
    };
  }
  const bridgeVersionMatch = BRIDGE_VERSION_PATTERN.exec(stdout);
  if (bridgeVersionMatch) {
    result.bridge = {
      version: _semver.default.coerce(bridgeVersionMatch[1])
    };
  }
  return result;
});
systemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady(timeoutMs = 20000) {
  if ((await this.getApiLevel()) >= 31) {
    let reason;
    try {
      await (0, _asyncbox.waitForCondition)(async () => {
        try {
          reason = await this.shell(['cmd', 'reboot_readiness', 'check-subsystems-state', '--list-blocking']);
        } catch (err) {
          reason = err.stdout || err.stderr;
          if (!_lodash.default.includes(reason, SUBSYSTEM_STATE_OK)) {
            _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);
          }
        }
        return _lodash.default.includes(reason, SUBSYSTEM_STATE_OK);
      }, {
        waitMs: timeoutMs,
        intervalMs: 1000
      });
      return;
    } catch (e) {
      throw new Error(`Emulator is not ready within ${timeoutMs}ms${reason ? '. Reason: ' + reason : ''}`);
    }
  }
  const requiredServicesRe = REQUIRED_SERVICES.map(name => new RegExp(`\\b${name}:`));
  let services;
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        services = await this.shell(['service', 'list']);
        return requiredServicesRe.every(pattern => pattern.test(services));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);
        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    if (services) {
      _logger.default.debug(`Recently listed services:\n${services}`);
    }
    const missingServices = _lodash.default.zip(REQUIRED_SERVICES, requiredServicesRe).filter(([, pattern]) => !pattern.test(services)).map(([name]) => name);
    throw new Error(`Emulator is not ready within ${timeoutMs}ms ` + `(${missingServices} service${missingServices.length === 1 ? ' is' : 's are'} not running)`);
  }
};
systemCallMethods.waitForDevice = async function waitForDevice(appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) * 1000 / retries;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      try {
        await this.reconnect();
      } catch (ign) {
        await this.restartAdb();
      }
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};
systemCallMethods.reboot = async function reboot(retries = DEFAULT_ADB_REBOOT_RETRIES) {
  const {
    wasAlreadyRooted
  } = await this.root();
  try {
    await this.shell(['stop']);
    await _bluebird.default.delay(2000);
    await this.setDeviceProperty('sys.boot_completed', 0, {
      privileged: false
    });
    await this.shell(['start']);
  } catch (e) {
    const {
      message
    } = e;
    if (message.includes('must be root')) {
      throw new Error(`Could not reboot device. Rebooting requires root access and ` + `attempt to get root access on device failed with error: '${message}'`);
    }
    throw e;
  } finally {
    if (!wasAlreadyRooted) {
      await this.unroot();
    }
  }
  const timer = new _support.timing.Timer().start();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }
    const msg = `Reboot is not completed after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`;
    _logger.default.debug(msg);
    throw new Error(msg);
  });
};
systemCallMethods.changeUserPrivileges = async function changeUserPrivileges(isElevated) {
  const cmd = isElevated ? 'root' : 'unroot';
  const retryIfOffline = async cmdFunc => {
    try {
      return await cmdFunc();
    } catch (err) {
      if (['closed', 'device offline', 'timeout expired'].some(x => (err.stderr || '').toLowerCase().includes(x))) {
        _logger.default.warn(`Attempt to ${cmd} caused ADB to think the device went offline`);
        try {
          await this.reconnect();
        } catch (ign) {
          await this.restartAdb();
        }
        return await cmdFunc();
      } else {
        throw err;
      }
    }
  };
  const isRoot = await retryIfOffline(async () => await this.isRoot());
  if (isRoot && isElevated || !isRoot && !isElevated) {
    return {
      isSuccessful: true,
      wasAlreadyRooted: isRoot
    };
  }
  let wasAlreadyRooted = isRoot;
  try {
    const {
      stdout
    } = await retryIfOffline(async () => await this.adbExec([cmd]));
    _logger.default.debug(stdout);
    if (stdout) {
      if (stdout.includes('adbd cannot run as root')) {
        return {
          isSuccessful: false,
          wasAlreadyRooted
        };
      }
      if (stdout.includes('already running as root')) {
        wasAlreadyRooted = true;
      }
    }
    return {
      isSuccessful: true,
      wasAlreadyRooted
    };
  } catch (err) {
    const {
      stderr = '',
      message
    } = err;
    _logger.default.warn(`Unable to ${cmd} adb daemon. Original error: '${message}'. Stderr: '${stderr}'. Continuing.`);
    return {
      isSuccessful: false,
      wasAlreadyRooted
    };
  }
};
systemCallMethods.root = async function root() {
  return await this.changeUserPrivileges(true);
};
systemCallMethods.unroot = async function unroot() {
  return await this.changeUserPrivileges(false);
};
systemCallMethods.isRoot = async function isRoot() {
  return (await this.shell(['whoami'])).trim() === 'root';
};
systemCallMethods.fileExists = async function fileExists(remotePath) {
  const passFlag = '__PASS__';
  const checkCmd = `[ -e '${remotePath.replace(/'/g, `\\'`)}' ] && echo ${passFlag}`;
  try {
    return _lodash.default.includes(await this.shell([checkCmd]), passFlag);
  } catch (ign) {
    return false;
  }
};
systemCallMethods.ls = async function ls(remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }
    return [];
  }
};
systemCallMethods.fileSize = async function fileSize(remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);
    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }
    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);
    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }
    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};
systemCallMethods.installMitmCertificate = async function installMitmCertificate(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();
  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }
  const tmpRoot = await _support.tempDir.openDir();
  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');
    await _support.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();
    _logger.default.debug(`Got certificate hash: ${certHash}`);
    _logger.default.debug('Preparing certificate content');
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);
    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);
    await _support.fs.writeFile(dstCert, dstCertContent);
    _logger.default.debug('Remounting /system in rw mode');
    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));
    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);
    await this.push(dstCert, CERTS_ROOT);
    _logger.default.debug('Remounting /system to confirm changes');
    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _support.fs.rimraf(tmpRoot);
  }
};
systemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();
  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }
  const tmpRoot = await _support.tempDir.openDir();
  let certHash;
  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');
    await _support.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _support.fs.rimraf(tmpRoot);
  }
  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);
  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);
  return await this.fileExists(dstPath);
};
var _default = systemCallMethods;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcGF0aCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2xvZ2dlciIsIl9ibHVlYmlyZCIsIl9zdXBwb3J0IiwiX2hlbHBlcnMiLCJfdGVlbl9wcm9jZXNzIiwiX2FzeW5jYm94IiwiX2xvZGFzaCIsIl9zZW12ZXIiLCJzeXN0ZW1DYWxsTWV0aG9kcyIsIkRFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTIiwiTElOS0VSX1dBUk5JTkdfUkVHRVhQIiwiQURCX1JFVFJZX0VSUk9SX1BBVFRFUk5TIiwiQklOQVJZX1ZFUlNJT05fUEFUVEVSTiIsIkJSSURHRV9WRVJTSU9OX1BBVFRFUk4iLCJDRVJUU19ST09UIiwiU0RLX0JJTkFSWV9ST09UUyIsIk1JTl9ERUxBWV9BREJfQVBJX0xFVkVMIiwiUkVRVUlSRURfU0VSVklDRVMiLCJTVUJTWVNURU1fU1RBVEVfT0siLCJnZXRTZGtCaW5hcnlQYXRoIiwiYmluYXJ5TmFtZSIsImdldEJpbmFyeUZyb21TZGtSb290IiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiXyIsIm1lbW9pemUiLCJnZXRCaW5hcnlOYW1lRm9yT1NNZW1vcml6ZSIsInN5c3RlbSIsImlzV2luZG93cyIsImluY2x1ZGVzIiwicGF0aCIsImV4dG5hbWUiLCJiaW5hcmllcyIsImZ1bGxCaW5hcnlOYW1lIiwiYmluYXJ5TG9jcyIsImdldFNka0JpbmFyeUxvY2F0aW9uQ2FuZGlkYXRlcyIsInNka1Jvb3QiLCJidWlsZFRvb2xzRGlycyIsImdldEJ1aWxkVG9vbHNEaXJzIiwiYnVpbGRUb29sc1ZlcnNpb24iLCJmaWx0ZXIiLCJ4IiwiYmFzZW5hbWUiLCJpc0VtcHR5IiwibG9nIiwiaW5mbyIsInB1c2giLCJmbGF0dGVuIiwibWFwIiwiZGlyIiwicmVzb2x2ZSIsImJpbmFyeUxvYyIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheSIsImdldEFuZHJvaWRCaW5hcnlQYXRoIiwiZ2V0U2RrUm9vdEZyb21FbnYiLCJnZXRCaW5hcnlGcm9tUGF0aCIsIndoaWNoIiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJvcHRzIiwiZGVidWciLCJhcmdzIiwiZXhlY3V0YWJsZSIsImRlZmF1bHRBcmdzIiwidmVyYm9zZSIsInN0ZG91dCIsImV4ZWMiLCJtZXNzYWdlIiwibGlzdEhlYWRlciIsInN0YXJ0aW5nSW5kZXgiLCJpbmRleE9mIiwic2xpY2UiLCJleGNsdWRlZExpbmVzIiwiYWxsb3dPZmZsaW5lRGV2aWNlcyIsImRldmljZXMiLCJzcGxpdCIsInRyaW0iLCJsaW5lIiwic29tZSIsInVkaWQiLCJzdGF0ZSIsImRlc2NyaXB0aW9uIiwiZGV2aWNlIiwiZW50cnkiLCJrZXkiLCJ2YWx1ZSIsImdldERldmljZXNXaXRoUmV0cnkiLCJ0aW1lb3V0TXMiLCJ0aW1lciIsInRpbWluZyIsIlRpbWVyIiwic3RhcnQiLCJnZXREZXZpY2VzIiwiZ2V0RHVyYXRpb24iLCJhc01pbGxpU2Vjb25kcyIsInRvRml4ZWQiLCJsZW5ndGgiLCJpZ24iLCJyZWNvbm5lY3QiLCJyZXN0YXJ0QWRiIiwic2xlZXAiLCJ0YXJnZXQiLCJhZGJFeGVjIiwic3RkZXJyIiwic3VwcHJlc3NLaWxsU2VydmVyIiwia2lsbFNlcnZlciIsImVycm9yIiwiYWRiUG9ydCIsImV4Y2x1c2l2ZSIsInJlc2V0VGVsbmV0QXV0aFRva2VuIiwiaG9tZUZvbGRlclBhdGgiLCJwcm9jZXNzIiwiZW52IiwicGxhdGZvcm0iLCJ3YXJuIiwiZHN0UGF0aCIsIndyaXRlRmlsZSIsImFkYkV4ZWNFbXUiLCJjbWQiLCJ2ZXJpZnlFbXVsYXRvckNvbm5lY3RlZCIsImlzRXhlY0xvY2tlZCIsIkVYRUNfT1VUUFVUX0ZPUk1BVCIsIk9iamVjdCIsImZyZWV6ZSIsIlNURE9VVCIsIkZVTEwiLCJjbG9uZURlZXAiLCJ0aW1lb3V0IiwiYWRiRXhlY1RpbWVvdXQiLCJERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQiLCJ0aW1lb3V0Q2FwTmFtZSIsIm91dHB1dEZvcm1hdCIsImFkYlJldHJpZWQiLCJleGVjRnVuYyIsImZpbmQiLCJhcmciLCJ0ZXN0IiwidXRpbCIsInF1b3RlIiwiam9pbiIsInJlcGxhY2UiLCJlcnJUZXh0IiwicCIsImNvZGUiLCJ3YWl0Rm9yQ29uZGl0aW9uIiwid2FpdE1zIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImludGVydmFsTXMiLCJzaGVsbCIsInByaXZpbGVnZWQiLCJjbWRBcnIiLCJmdWxsQ21kIiwiaXNSb290IiwiY3JlYXRlU3ViUHJvY2VzcyIsIlN1YlByb2Nlc3MiLCJnZXRBZGJQYXRoIiwiZ2V0QWRiU2VydmVyUG9ydCIsImdldEVtdWxhdG9yUG9ydCIsImVtdWxhdG9yUG9ydCIsInBvcnQiLCJnZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nIiwiZW1TdHIiLCJwb3J0UGF0dGVybiIsInBhcnNlSW50IiwiZ2V0Q29ubmVjdGVkRW11bGF0b3JzIiwiZW11bGF0b3JzIiwicGx1cmFsaXplIiwic2V0RW11bGF0b3JQb3J0IiwiZW1Qb3J0Iiwic2V0RGV2aWNlSWQiLCJkZXZpY2VJZCIsImN1ckRldmljZUlkIiwiYXJnc0hhc0RldmljZSIsInNwbGljZSIsInNldERldmljZSIsImRldmljZU9iaiIsImdldFJ1bm5pbmdBVkQiLCJhdmROYW1lIiwiZW11bGF0b3IiLCJydW5uaW5nQVZETmFtZSIsImV4ZWNFbXVDb25zb2xlQ29tbWFuZCIsImV4ZWNUaW1lb3V0IiwiY29ublRpbWVvdXQiLCJ0b0xvd2VyIiwiZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSIsImtpbGxBbGxFbXVsYXRvcnMiLCJraWxsRW11bGF0b3IiLCJoYXNWYWx1ZSIsImlzRW11bGF0b3JDb25uZWN0ZWQiLCJsYXVuY2hBVkQiLCJsYW5ndWFnZSIsImNvdW50cnkiLCJsYXVuY2hUaW1lb3V0IiwicmVhZHlUaW1lb3V0IiwicmV0cnlUaW1lcyIsImVtdWxhdG9yQmluYXJ5UGF0aCIsInN1YnN0ciIsImNoZWNrQXZkRXhpc3QiLCJsYXVuY2hBcmdzIiwidG9BdmRMb2NhbGVBcmdzIiwiaXNEZWxheUFkYkZlYXR1cmVFbmFibGVkIiwiYWxsb3dEZWxheUFkYiIsInJldmlzaW9uIiwiZ2V0RW11VmVyc2lvbkluZm8iLCJjb21wYXJlVmVyc2lvbnMiLCJnZXRFbXVJbWFnZVByb3BlcnRpZXMiLCJhcGlNYXRjaCIsInNoZWxsUGFyc2UiLCJwcm9jIiwiYXNzaWduIiwib24iLCJCb29sZWFuIiwic2lnbmFsIiwicmV0cnkiLCJ3YWl0Rm9yRW11bGF0b3JSZWFkeSIsImdldFZlcnNpb24iLCJyZXN1bHQiLCJiaW5hcnlWZXJzaW9uTWF0Y2giLCJiaW5hcnkiLCJ2ZXJzaW9uIiwic2VtdmVyIiwiY29lcmNlIiwiYnVpbGQiLCJicmlkZ2VWZXJzaW9uTWF0Y2giLCJicmlkZ2UiLCJnZXRBcGlMZXZlbCIsInJlYXNvbiIsImVyciIsInJlcXVpcmVkU2VydmljZXNSZSIsIm5hbWUiLCJSZWdFeHAiLCJzZXJ2aWNlcyIsImV2ZXJ5IiwicGF0dGVybiIsIm1pc3NpbmdTZXJ2aWNlcyIsInppcCIsIndhaXRGb3JEZXZpY2UiLCJhcHBEZXZpY2VSZWFkeVRpbWVvdXQiLCJyZXRyaWVzIiwicGluZyIsInJlYm9vdCIsIndhc0FscmVhZHlSb290ZWQiLCJyb290IiwiQiIsImRlbGF5Iiwic2V0RGV2aWNlUHJvcGVydHkiLCJ1bnJvb3QiLCJyZXRyeUludGVydmFsIiwiZ2V0RGV2aWNlUHJvcGVydHkiLCJtc2ciLCJjaGFuZ2VVc2VyUHJpdmlsZWdlcyIsImlzRWxldmF0ZWQiLCJyZXRyeUlmT2ZmbGluZSIsImNtZEZ1bmMiLCJ0b0xvd2VyQ2FzZSIsImlzU3VjY2Vzc2Z1bCIsImZpbGVFeGlzdHMiLCJyZW1vdGVQYXRoIiwicGFzc0ZsYWciLCJjaGVja0NtZCIsImxzIiwibGluZXMiLCJsIiwiZmlsZVNpemUiLCJmaWxlcyIsIm1hdGNoIiwiaXNOYU4iLCJpbnN0YWxsTWl0bUNlcnRpZmljYXRlIiwiY2VydCIsIm9wZW5Tc2wiLCJnZXRPcGVuU3NsRm9yT3MiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ0bXBSb290IiwidGVtcERpciIsIm9wZW5EaXIiLCJzcmNDZXJ0IiwiY2VydEhhc2giLCJkc3RDZXJ0Q29udGVudCIsImNvbmNhdCIsImRzdENlcnQiLCJyaW1yYWYiLCJpc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCIsInRtcENlcnQiLCJwb3NpeCIsIl9kZWZhdWx0IiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgdXRpbCwgdGVtcERpciwgdGltaW5nIH0gZnJvbSAnQGFwcGl1bS9zdXBwb3J0JztcbmltcG9ydCB7XG4gIGdldEJ1aWxkVG9vbHNEaXJzLCB0b0F2ZExvY2FsZUFyZ3MsXG4gIGdldE9wZW5Tc2xGb3JPcywgREVGQVVMVF9BREJfRVhFQ19USU1FT1VULCBnZXRTZGtSb290RnJvbUVudlxufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7IGV4ZWMsIFN1YlByb2Nlc3MgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgc2xlZXAsIHJldHJ5LCByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuXG5sZXQgc3lzdGVtQ2FsbE1ldGhvZHMgPSB7fTtcblxuY29uc3QgREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMgPSA5MDtcbmNvbnN0IExJTktFUl9XQVJOSU5HX1JFR0VYUCA9IC9eV0FSTklORzogbGlua2VyLiskL207XG5jb25zdCBBREJfUkVUUllfRVJST1JfUEFUVEVSTlMgPSBbXG4gIC9wcm90b2NvbCBmYXVsdCBcXChubyBzdGF0dXNcXCkvaSxcbiAgL2Vycm9yOiBkZXZpY2UgKCcuKycgKT9ub3QgZm91bmQvaSxcbiAgL2Vycm9yOiBkZXZpY2Ugc3RpbGwgY29ubmVjdGluZy9pLFxuXTtcbmNvbnN0IEJJTkFSWV9WRVJTSU9OX1BBVFRFUk4gPSAvXlZlcnNpb24gKFtcXGQuXSspLShcXGQrKS9tO1xuY29uc3QgQlJJREdFX1ZFUlNJT05fUEFUVEVSTiA9IC9eQW5kcm9pZCBEZWJ1ZyBCcmlkZ2UgdmVyc2lvbiAoW1xcZC5dKykvbTtcbmNvbnN0IENFUlRTX1JPT1QgPSAnL3N5c3RlbS9ldGMvc2VjdXJpdHkvY2FjZXJ0cyc7XG5jb25zdCBTREtfQklOQVJZX1JPT1RTID0gW1xuICAncGxhdGZvcm0tdG9vbHMnLFxuICAnZW11bGF0b3InLFxuICBbJ2NtZGxpbmUtdG9vbHMnLCAnbGF0ZXN0JywgJ2JpbiddLFxuICAndG9vbHMnLFxuICBbJ3Rvb2xzJywgJ2JpbiddLFxuICAnLicgLy8gQWxsb3cgY3VzdG9tIHNka1Jvb3QgdG8gc3BlY2lmeSBmdWxsIGZvbGRlciBwYXRoXG5dO1xuY29uc3QgTUlOX0RFTEFZX0FEQl9BUElfTEVWRUwgPSAyODtcbmNvbnN0IFJFUVVJUkVEX1NFUlZJQ0VTID0gWydhY3Rpdml0eScsICdwYWNrYWdlJywgJ21vdW50J107XG5jb25zdCBTVUJTWVNURU1fU1RBVEVfT0sgPSAnU3Vic3lzdGVtIHN0YXRlOiB0cnVlJztcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5IGluY2x1ZGluZyBjdXJyZW50IFNESyByb290LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRTZGtCaW5hcnlQYXRoID0gYXN5bmMgZnVuY3Rpb24gZ2V0U2RrQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tU2RrUm9vdChiaW5hcnlOYW1lKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBiaW5hcnkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbSBhcyBtZW1vdGl6ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIHNpbXBsZSBiaW5hcnkgbmFtZSwgZm9yIGV4YW1wbGUgJ2FuZHJvaWQnLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgYmluYXJ5IG5hbWUgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtLFxuICogICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgJ2FuZHJvaWQuYmF0JyBvbiBXaW5kb3dzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlOYW1lRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZUZvck9TTWVtb3JpemUgKGJpbmFyeU5hbWUpIHtcbiAgcmV0dXJuIGdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgYmluYXJ5IG5hbWUgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBzaW1wbGUgYmluYXJ5IG5hbWUsIGZvciBleGFtcGxlICdhbmRyb2lkJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIGJpbmFyeSBuYW1lIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybSxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsICdhbmRyb2lkLmJhdCcgb24gV2luZG93cy5cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZUZvck9TIChiaW5hcnlOYW1lKSB7XG4gIGlmICghc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgcmV0dXJuIGJpbmFyeU5hbWU7XG4gIH1cblxuICBpZiAoWydhbmRyb2lkJywgJ2Fwa3NpZ25lcicsICdhcGthbmFseXplciddLmluY2x1ZGVzKGJpbmFyeU5hbWUpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmJhdGA7XG4gIH1cbiAgaWYgKCFwYXRoLmV4dG5hbWUoYmluYXJ5TmFtZSkpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeSBhbmQgY2FjaGVzIGl0IGludG8gYGJpbmFyaWVzYFxuICogcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgQURCIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gU2ltcGxlIG5hbWUgb2YgYSBiaW5hcnkgZmlsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuIFRoZSBtZXRob2QgdHJpZXNcbiAqICAgICAgICAgICAgICAgICAgdG8gZW51bWVyYXRlIGFsbCB0aGUga25vd24gbG9jYXRpb25zIHdoZXJlIHRoZSBiaW5hcnlcbiAqICAgICAgICAgICAgICAgICAgbWlnaHQgYmUgbG9jYXRlZCBhbmQgc3RvcHMgdGhlIHNlYXJjaCBhcyBzb29uIGFzIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgICBtYXRjaCBpcyBmb3VuZCBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSB3aXRoIGdpdmVuIG5hbWUgaXMgbm90IHByZXNlbnQgYXQgYW55XG4gKiAgICAgICAgICAgICAgICAgb2Yga25vd24gbG9jYXRpb25zIG9yIEFuZHJvaWQgU0RLIGlzIG5vdCBpbnN0YWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21TZGtSb290ID0gYXN5bmMgZnVuY3Rpb24gZ2V0QmluYXJ5RnJvbVNka1Jvb3QgKGJpbmFyeU5hbWUpIHtcbiAgaWYgKHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV0pIHtcbiAgICByZXR1cm4gdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXTtcbiAgfVxuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBjb25zdCBiaW5hcnlMb2NzID0gZ2V0U2RrQmluYXJ5TG9jYXRpb25DYW5kaWRhdGVzKHRoaXMuc2RrUm9vdCwgZnVsbEJpbmFyeU5hbWUpO1xuXG4gIC8vIGdldCBzdWJwYXRocyBmb3IgY3VycmVudGx5IGluc3RhbGxlZCBidWlsZCB0b29sIGRpcmVjdG9yaWVzXG4gIGxldCBidWlsZFRvb2xzRGlycyA9IGF3YWl0IGdldEJ1aWxkVG9vbHNEaXJzKHRoaXMuc2RrUm9vdCk7XG4gIGlmICh0aGlzLmJ1aWxkVG9vbHNWZXJzaW9uKSB7XG4gICAgYnVpbGRUb29sc0RpcnMgPSBidWlsZFRvb2xzRGlyc1xuICAgICAgLmZpbHRlcigoeCkgPT4gcGF0aC5iYXNlbmFtZSh4KSA9PT0gdGhpcy5idWlsZFRvb2xzVmVyc2lvbik7XG4gICAgaWYgKF8uaXNFbXB0eShidWlsZFRvb2xzRGlycykpIHtcbiAgICAgIGxvZy5pbmZvKGBGb3VuZCBubyBidWlsZCB0b29scyB3aG9zZSB2ZXJzaW9uIG1hdGNoZXMgdG8gJyR7dGhpcy5idWlsZFRvb2xzVmVyc2lvbn0nYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGBVc2luZyBidWlsZCB0b29scyBhdCAnJHtidWlsZFRvb2xzRGlyc30nYCk7XG4gICAgfVxuICB9XG4gIGJpbmFyeUxvY3MucHVzaCguLi4oXy5mbGF0dGVuKGJ1aWxkVG9vbHNEaXJzXG4gICAgLm1hcCgoZGlyKSA9PiBbXG4gICAgICBwYXRoLnJlc29sdmUoZGlyLCBmdWxsQmluYXJ5TmFtZSksXG4gICAgICBwYXRoLnJlc29sdmUoZGlyLCAnbGliJywgZnVsbEJpbmFyeU5hbWUpLFxuICAgIF0pKVxuICApKTtcblxuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgZm9yIChjb25zdCBsb2Mgb2YgYmluYXJ5TG9jcykge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMobG9jKSkge1xuICAgICAgYmluYXJ5TG9jID0gbG9jO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChfLmlzTnVsbChiaW5hcnlMb2MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAnJHtmdWxsQmluYXJ5TmFtZX0nIGluICR7SlNPTi5zdHJpbmdpZnkoYmluYXJ5TG9jcyl9LiBgICtcbiAgICAgIGBEbyB5b3UgaGF2ZSBBbmRyb2lkIEJ1aWxkIFRvb2xzICR7dGhpcy5idWlsZFRvb2xzVmVyc2lvbiA/IGB2ICR7dGhpcy5idWlsZFRvb2xzVmVyc2lvbn0gYCA6ICcnfWAgK1xuICAgICAgYGluc3RhbGxlZCBhdCAnJHt0aGlzLnNka1Jvb3R9Jz9gKTtcbiAgfVxuICBsb2cuaW5mbyhgVXNpbmcgJyR7ZnVsbEJpbmFyeU5hbWV9JyBmcm9tICcke2JpbmFyeUxvY30nYCk7XG4gIHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV0gPSBiaW5hcnlMb2M7XG4gIHJldHVybiBiaW5hcnlMb2M7XG59O1xuXG4vKipcbiAqICBSZXR1cm5zIHRoZSBBbmRyb2lkIGJpbmFyaWVzIGxvY2F0aW9uc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZGtSb290IFRoZSBwYXRoIHRvIEFuZHJvaWQgU0RLIHJvb3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVsbEJpbmFyeU5hbWUgVGhlIG5hbWUgb2YgZnVsbCBiaW5hcnkgbmFtZS5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IFRoZSBsaXN0IG9mIFNES19CSU5BUllfUk9PVFMgcGF0aHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHNka1Jvb3QgYW5kIGZ1bGxCaW5hcnlOYW1lLlxuICovXG5mdW5jdGlvbiBnZXRTZGtCaW5hcnlMb2NhdGlvbkNhbmRpZGF0ZXMgKHNka1Jvb3QsIGZ1bGxCaW5hcnlOYW1lKSB7XG4gIHJldHVybiBTREtfQklOQVJZX1JPT1RTLm1hcCgoeCkgPT5cbiAgICBwYXRoLnJlc29sdmUoc2RrUm9vdCwgLi4uKF8uaXNBcnJheSh4KSA/IHggOiBbeF0pLCBmdWxsQmluYXJ5TmFtZSkpO1xufVxuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgaGF2ZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFNpbXBsZSBuYW1lIG9mIGEgYmluYXJ5IGZpbGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gJ2FkYicsICdhbmRyb2lkJ1xuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS4gVGhlIG1ldGhvZCB0cmllc1xuICogICAgICAgICAgICAgICAgICB0byBlbnVtZXJhdGUgYWxsIHRoZSBrbm93biBsb2NhdGlvbnMgd2hlcmUgdGhlIGJpbmFyeVxuICogICAgICAgICAgICAgICAgICBtaWdodCBiZSBsb2NhdGVkIGFuZCBzdG9wcyB0aGUgc2VhcmNoIGFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiAgICAgICAgICAgICAgICAgIG1hdGNoIGlzIGZvdW5kIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbS5cbiAqICAgICAgICAgICAgICAgICAgZS5nLiAnL1BhdGgvVG8vQW5kcm9pZC9zZGsvcGxhdGZvcm0tdG9vbHMvYWRiJ1xuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBiaW5hcnkgd2l0aCBnaXZlbiBuYW1lIGlzIG5vdCBwcmVzZW50IGF0IGFueVxuICogICAgICAgICAgICAgICAgIG9mIGtub3duIGxvY2F0aW9ucyBvciBBbmRyb2lkIFNESyBpcyBub3QgaW5zdGFsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBbmRyb2lkQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IGdldEJpbmFyeU5hbWVGb3JPUyhiaW5hcnlOYW1lKTtcbiAgY29uc3Qgc2RrUm9vdCA9IGdldFNka1Jvb3RGcm9tRW52KCk7XG4gIGNvbnN0IGJpbmFyeUxvY3MgPSBnZXRTZGtCaW5hcnlMb2NhdGlvbkNhbmRpZGF0ZXMoc2RrUm9vdCwgZnVsbEJpbmFyeU5hbWUpO1xuICBmb3IgKGNvbnN0IGxvYyBvZiBiaW5hcnlMb2NzKSB7XG4gICAgaWYgKGF3YWl0IGZzLmV4aXN0cyhsb2MpKSB7XG4gICAgICByZXR1cm4gbG9jO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICcke2Z1bGxCaW5hcnlOYW1lfScgaW4gJHtKU09OLnN0cmluZ2lmeShiaW5hcnlMb2NzKX0uIGAgK1xuICAgIGBEbyB5b3UgaGF2ZSBBbmRyb2lkIEJ1aWxkIFRvb2xzIGluc3RhbGxlZCBhdCAnJHtzZGtSb290fSc/YCk7XG59XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldEJpbmFyeUZyb21QYXRoIChiaW5hcnlOYW1lKSB7XG4gIGlmICh0aGlzLmJpbmFyaWVzW2JpbmFyeU5hbWVdKSB7XG4gICAgcmV0dXJuIHRoaXMuYmluYXJpZXNbYmluYXJ5TmFtZV07XG4gIH1cblxuICBjb25zdCBmdWxsQmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICB0cnkge1xuICAgIGNvbnN0IGJpbmFyeUxvYyA9IGF3YWl0IGZzLndoaWNoKGZ1bGxCaW5hcnlOYW1lKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJyR7ZnVsbEJpbmFyeU5hbWV9JyBmcm9tICcke2JpbmFyeUxvY30nYCk7XG4gICAgdGhpcy5iaW5hcmllc1tiaW5hcnlOYW1lXSA9IGJpbmFyeUxvYztcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAnJHtmdWxsQmluYXJ5TmFtZX0nIGluIFBBVEguIFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgIGBvciBBTkRST0lEX1NES19ST09UIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgY29ycmVjdCBBbmRyb2lkIFNESyByb290IGRpcmVjdG9yeSBwYXRoLmApO1xuICB9XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbm5lY3RlZERldmljZXNPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB2ZXJib3NlIC0gV2hldGhlciB0byBnZXQgbG9uZyBvdXRwdXQsIHdoaWNoIGluY2x1ZGVzIGV4dHJhIHByb3BlcnRpZXMgaW4gZWFjaCBkZXZpY2UuXG4gKiBBa2luIHRvIHJ1bm5pbmcgYGFkYiBkZXZpY2VzIC1sYC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVkaWQgLSBUaGUgZGV2aWNlIHVkaWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdGUgLSBDdXJyZW50IGRldmljZSBzdGF0ZSwgYXMgaXQgaXMgdmlzaWJsZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FkYiBkZXZpY2VzIC1sXyBvdXRwdXQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RGV2aWNlfSBWZXJib3NlRGV2aWNlIEFkZGl0aW9uYWwgcHJvcGVydGllcyByZXR1cm5lZCB3aGVuIGB2ZXJib3NlYCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb2R1Y3QgLSBUaGUgcHJvZHVjdCBjb2RlbmFtZSBvZiB0aGUgZGV2aWNlLCBzdWNoIGFzIFwicmF6b3JcIi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtb2RlbCAtIFRoZSBtb2RlbCBuYW1lIG9mIHRoZSBkZXZpY2UsIHN1Y2ggYXMgXCJOZXh1c183XCIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGV2aWNlIC0gVGhlIGRldmljZSBjb2RlbmFtZSwgc3VjaCBhcyBcImZsb3dcIi5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdXNiIC0gUmVwcmVzZW50cyB0aGUgVVNCIHBvcnQgdGhlIGRldmljZSBpcyBjb25uZWN0ZWQgdG8sIHN1Y2ggYXMgXCIxLTFcIi5cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdHJhbnNwb3J0X2lkIC0gVGhlIFRyYW5zcG9ydCBJRCBmb3IgdGhlIGRldmljZSwgc3VjaCBhcyBcIjFcIi5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIuXG4gKlxuICogQHBhcmFtIHs/Q29ubmVjdGVkRGV2aWNlc09wdGlvbnN9IG9wdHMgW3t9XSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGRldmljZXMgb3IgYW4gZW1wdHkgbGlzdCBpZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG5vIGRldmljZXMgYXJlIGNvbm5lY3RlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbGlzdGluZyBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWREZXZpY2VzID0gYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAob3B0cyA9IHt9KSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcycpO1xuICBjb25zdCBhcmdzID0gWy4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgJ2RldmljZXMnXTtcbiAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgIGFyZ3MucHVzaCgnLWwnKTtcbiAgfVxuXG4gIGxldCBzdGRvdXQ7XG4gIHRyeSB7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBnZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgY29uc3QgbGlzdEhlYWRlciA9ICdMaXN0IG9mIGRldmljZXMnO1xuICAvLyBleHBlY3RpbmcgYWRiIGRldmljZXMgdG8gcmV0dXJuIG91dHB1dCBhc1xuICAvLyBMaXN0IG9mIGRldmljZXMgYXR0YWNoZWRcbiAgLy8gZW11bGF0b3ItNTU1NFx0ZGV2aWNlXG4gIGNvbnN0IHN0YXJ0aW5nSW5kZXggPSBzdGRvdXQuaW5kZXhPZihsaXN0SGVhZGVyKTtcbiAgaWYgKHN0YXJ0aW5nSW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXM6ICR7c3Rkb3V0fWApO1xuICB9XG4gIC8vIHNsaWNpbmcgb3V0cHV0IHdlIGNhcmUgYWJvdXRcbiAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICBsZXQgZXhjbHVkZWRMaW5lcyA9IFtsaXN0SGVhZGVyLCAnYWRiIHNlcnZlcicsICcqIGRhZW1vbiddO1xuICBpZiAoIXRoaXMuYWxsb3dPZmZsaW5lRGV2aWNlcykge1xuICAgIGV4Y2x1ZGVkTGluZXMucHVzaCgnb2ZmbGluZScpO1xuICB9XG4gIGNvbnN0IGRldmljZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpXG4gICAgLm1hcChfLnRyaW0pXG4gICAgLmZpbHRlcigobGluZSkgPT4gbGluZSAmJiAhZXhjbHVkZWRMaW5lcy5zb21lKCh4KSA9PiBsaW5lLmluY2x1ZGVzKHgpKSlcbiAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICAvLyBzdGF0ZSBpcyBcImRldmljZVwiLCBhZmFpY1xuICAgICAgY29uc3QgW3VkaWQsIHN0YXRlLCAuLi5kZXNjcmlwdGlvbl0gPSBsaW5lLnNwbGl0KC9cXHMrLyk7XG4gICAgICBjb25zdCBkZXZpY2UgPSB7dWRpZCwgc3RhdGV9O1xuICAgICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIC8vIGVhY2ggZW50cnkgbG9va3MgbGlrZSBrZXk6dmFsdWVcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBkZXZpY2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZTtcbiAgICB9KTtcbiAgaWYgKF8uaXNFbXB0eShkZXZpY2VzKSkge1xuICAgIGxvZy5kZWJ1ZygnTm8gY29ubmVjdGVkIGRldmljZXMgaGF2ZSBiZWVuIGRldGVjdGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLmRlYnVnKGBDb25uZWN0ZWQgZGV2aWNlczogJHtKU09OLnN0cmluZ2lmeShkZXZpY2VzKX1gKTtcbiAgfVxuICByZXR1cm4gZGV2aWNlcztcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYiB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZ2V0IGF0IGxlYXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGxpc3QgaXRlbS5cbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBjb25uZWN0ZWQgZGV2aWNlcyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXREZXZpY2VzV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlc1dpdGhSZXRyeSAodGltZW91dE1zID0gMjAwMDApIHtcbiAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgbG9nLmRlYnVnKCdUcnlpbmcgdG8gZmluZCBhIGNvbm5lY3RlZCBhbmRyb2lkIGRldmljZScpO1xuICBjb25zdCBnZXREZXZpY2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICh0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzID4gdGltZW91dE1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlIGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc01pbGxpU2Vjb25kcy50b0ZpeGVkKDApfW1zLmApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgICAgaWYgKGRldmljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gZGV2aWNlcztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChpZ24pIHt9XG5cbiAgICBsb2cuZGVidWcoJ0NvdWxkIG5vdCBmaW5kIG9ubGluZSBkZXZpY2VzJyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucmVjb25uZWN0KCk7XG4gICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICB9XG4gICAgLy8gY29vbCBkb3duXG4gICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICB9O1xuICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xufTtcblxuLyoqXG4gKiBLaWNrIGN1cnJlbnQgY29ubmVjdGlvbiBmcm9tIGhvc3QvZGV2aWNlIHNpZGUgYW5kIG1ha2UgaXQgcmVjb25uZWN0XG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSB0YXJnZXQgW29mZmxpbmVdIE9uZSBvZiBwb3NzaWJsZSB0YXJnZXRzIHRvIHJlY29ubmVjdDpcbiAqIG9mZmxpbmUsIGRldmljZSBvciBudWxsXG4gKiBQcm92aWRpbmcgYG51bGxgIHdpbGwgY2F1c2UgcmVjb25uZWN0aW9uIHRvIGhhcHBlbiBmcm9tIHRoZSBob3N0IHNpZGUuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGVpdGhlciBBREIgdmVyc2lvbiBpcyB0b28gb2xkIGFuZCBkb2VzIG5vdCBzdXBwb3J0IHRoaXNcbiAqIGNvbW1hbmQgb3IgdGhlcmUgd2FzIGEgZmFpbHVyZSBkdXJpbmcgcmVjb25uZWN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZWNvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiByZWNvbm5lY3QgKHRhcmdldCA9ICdvZmZsaW5lJykge1xuICBsb2cuZGVidWcoYFJlY29ubmVjdGluZyBhZGIgKHRhcmdldCAke3RhcmdldH0pYCk7XG5cbiAgY29uc3QgYXJncyA9IFsncmVjb25uZWN0J107XG4gIGlmICh0YXJnZXQpIHtcbiAgICBhcmdzLnB1c2godGFyZ2V0KTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlY29ubmVjdCBhZGIuIE9yaWdpbmFsIGVycm9yOiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN0YXJ0IGFkYiBzZXJ2ZXIsIHVubGVzcyBfdGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXJfIHByb3BlcnR5IGlzIHRydWUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc3RhcnRBZGIgPSBhc3luYyBmdW5jdGlvbiByZXN0YXJ0QWRiICgpIHtcbiAgaWYgKHRoaXMuc3VwcHJlc3NLaWxsU2VydmVyKSB7XG4gICAgbG9nLmRlYnVnKGBOb3QgcmVzdGFydGluZyBhYmQgc2luY2UgJ3N1cHByZXNzS2lsbFNlcnZlcicgaXMgb25gKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2cuZGVidWcoJ1Jlc3RhcnRpbmcgYWRiJyk7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy5raWxsU2VydmVyKCk7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnc3RhcnQtc2VydmVyJ10pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yKGBFcnJvciBraWxsaW5nIEFEQiBzZXJ2ZXIsIGdvaW5nIHRvIHNlZSBpZiBpdCdzIG9ubGluZSBhbnl3YXlgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIGFkYiBzZXJ2ZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxTZXJ2ZXIgPSBhc3luYyBmdW5jdGlvbiBraWxsU2VydmVyICgpIHtcbiAgbG9nLmRlYnVnKGBLaWxsaW5nIGFkYiBzZXJ2ZXIgb24gcG9ydCAnJHt0aGlzLmFkYlBvcnR9J2ApO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydraWxsLXNlcnZlciddLCB7XG4gICAgZXhjbHVzaXZlOiB0cnVlLFxuICB9KTtcbn07XG5cbi8qKlxuICogUmVzZXQgVGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmFuZHJvaWQuY29tL3JlY2VudC9lbXVsYXRvcjI1MTZyZWxlYXNlbm90ZXN9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IElmIHRva2VuIHJlc2V0IHdhcyBzdWNjZXNzZnVsLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXNldFRlbG5ldEF1dGhUb2tlbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiByZXNldFRlbG5ldEF1dGhUb2tlbiAoKSB7XG4gIC8vIFRoZSBtZXRob2RzIGlzIHVzZWQgdG8gcmVtb3ZlIHRlbG5ldCBhdXRoIHRva2VuXG4gIC8vXG4gIGNvbnN0IGhvbWVGb2xkZXJQYXRoID0gcHJvY2Vzcy5lbnZbKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpID8gJ1VTRVJQUk9GSUxFJyA6ICdIT01FJ107XG4gIGlmICghaG9tZUZvbGRlclBhdGgpIHtcbiAgICBsb2cud2FybihgQ2Fubm90IGZpbmQgdGhlIHBhdGggdG8gdXNlciBob21lIGZvbGRlci4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoaG9tZUZvbGRlclBhdGgsICcuZW11bGF0b3JfY29uc29sZV9hdXRoX3Rva2VuJyk7XG4gIGxvZy5kZWJ1ZyhgT3ZlcnJpZGluZyAke2RzdFBhdGh9IHdpdGggYW4gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHRlbG5ldCBhdXRoZW50aWNhdGlvbiBmb3IgZW11bGF0b3IgY29tbWFuZHNgKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLndhcm4oYEVycm9yICR7ZS5tZXNzYWdlfSB3aGlsZSByZXNldHRpbmcgdGhlIGNvbnRlbnQgb2YgJHtkc3RQYXRofS4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yJ3MgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSk7XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gZW11bGF0b3IgY29tbWFuZCB1c2luZyBfYWRiIGVtdV8gdG9vbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlY0VtdSA9IGFzeW5jIGZ1bmN0aW9uIGFkYkV4ZWNFbXUgKGNtZCkge1xuICBhd2FpdCB0aGlzLnZlcmlmeUVtdWxhdG9yQ29ubmVjdGVkKCk7XG4gIGF3YWl0IHRoaXMucmVzZXRUZWxuZXRBdXRoVG9rZW4oKTtcbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgLi4uY21kXSk7XG59O1xuXG5sZXQgaXNFeGVjTG9ja2VkID0gZmFsc2U7XG5cbnN5c3RlbUNhbGxNZXRob2RzLkVYRUNfT1VUUFVUX0ZPUk1BVCA9IE9iamVjdC5mcmVlemUoe1xuICBTVERPVVQ6ICdzdGRvdXQnLFxuICBGVUxMOiAnZnVsbCcsXG59KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFeGVjUmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3Rkb3V0IFRoZSBzdGRvdXQgcmVjZWl2ZWQgZnJvbSBleGVjXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RkZXJyIFRoZSBzdGRlcnIgcmVjZWl2ZWQgZnJvbSBleGVjXG4gKi9cblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBhbHNvIHNldCB0aGUgYWRkaXRpb25hbCBgZXhjbHVzaXZlYCBwYXJhbVxuICogICAgICAgICAgICAgICAgICAgICAgICB0byBgdHJ1ZWAgdGhhdCBhc3N1cmVzIG5vIG90aGVyIHBhcmFsbGVsIGFkYiBjb21tYW5kc1xuICogICAgICAgICAgICAgICAgICAgICAgICBhcmUgZ29pbmcgdG8gYmUgZXhlY3V0ZWQgd2hpbGUgdGhlIGN1cnJlbnQgb25lIGlzIHJ1bm5pbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBzZXQgdGhlIGBvdXRwdXRGb3JtYXRgIHBhcmFtIHRvIGBzdGRvdXRgIHRvIHJlY2VpdmUganVzdCB0aGUgc3Rkb3V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCAoZGVmYXVsdCkgb3IgYGZ1bGxgIHRvIHJlY2VpdmUgdGhlIHN0ZG91dCBhbmQgc3RkZXJyIHJlc3BvbnNlIGZyb20gYVxuICogICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kIHdpdGggYSB6ZXJvIGV4aXQgY29kZVxuICogQHJldHVybiB7c3RyaW5nfEV4ZWNSZXN1bHR9IC0gQ29tbWFuZCdzIHN0ZG91dCBvciBhbiBvYmplY3QgY29udGFpbmluZyBzdGRvdXQgYW5kIHN0ZGVyci5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWMgPSBhc3luYyBmdW5jdGlvbiBhZGJFeGVjIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcGFzcyBpbiBhIGNvbW1hbmQgdG8gYWRiRXhlYygpJyk7XG4gIH1cblxuICBvcHRzID0gXy5jbG9uZURlZXAob3B0cyk7XG4gIC8vIHNldHRpbmcgZGVmYXVsdCB0aW1lb3V0IGZvciBlYWNoIGNvbW1hbmQgdG8gcHJldmVudCBpbmZpbml0ZSB3YWl0LlxuICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy5hZGJFeGVjVGltZW91dCB8fCBERUZBVUxUX0FEQl9FWEVDX1RJTUVPVVQ7XG4gIG9wdHMudGltZW91dENhcE5hbWUgPSBvcHRzLnRpbWVvdXRDYXBOYW1lIHx8ICdhZGJFeGVjVGltZW91dCc7IC8vIEZvciBlcnJvciBtZXNzYWdlXG5cbiAgY29uc3Qge291dHB1dEZvcm1hdCA9IHRoaXMuRVhFQ19PVVRQVVRfRk9STUFULlNURE9VVH0gPSBvcHRzO1xuXG4gIGNtZCA9IF8uaXNBcnJheShjbWQpID8gY21kIDogW2NtZF07XG4gIGxldCBhZGJSZXRyaWVkID0gZmFsc2U7XG4gIGNvbnN0IGV4ZWNGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhcmdzID0gWy4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgLi4uY21kXTtcbiAgICAgIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHt0aGlzLmV4ZWN1dGFibGUucGF0aH0gYCArXG4gICAgICAgIChhcmdzLmZpbmQoKGFyZykgPT4gL1xccysvLnRlc3QoYXJnKSkgPyB1dGlsLnF1b3RlKGFyZ3MpIDogYXJncy5qb2luKCcgJykpICsgYCdgKTtcbiAgICAgIGxldCB7c3Rkb3V0LCBzdGRlcnJ9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncywgb3B0cyk7XG4gICAgICAvLyBzb21ldGltZXMgQURCIHByaW50cyBvdXQgd2VpcmQgc3Rkb3V0IHdhcm5pbmdzIHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpbiBhbnkgb2YgdGhlIHJlc3BvbnNlIGRhdGEsIHNvIGxldCdzIHN0cmlwIGl0IG91dFxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIG91dHB1dEZvcm1hdCA9PT0gdGhpcy5FWEVDX09VVFBVVF9GT1JNQVQuRlVMTCA/IHtzdGRvdXQsIHN0ZGVycn0gOiBzdGRvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyVGV4dCA9IGAke2UubWVzc2FnZX0sICR7ZS5zdGRvdXR9LCAke2Uuc3RkZXJyfWA7XG4gICAgICBpZiAoQURCX1JFVFJZX0VSUk9SX1BBVFRFUk5TLnNvbWUoKHApID0+IHAudGVzdChlcnJUZXh0KSkpIHtcbiAgICAgICAgbG9nLmluZm8oYEVycm9yIHNlbmRpbmcgY29tbWFuZCwgcmVjb25uZWN0aW5nIGRldmljZSBhbmQgcmV0cnlpbmc6ICR7Y21kfWApO1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREZXZpY2VzV2l0aFJldHJ5KCk7XG5cbiAgICAgICAgLy8gdHJ5IGFnYWluIG9uZSB0aW1lXG4gICAgICAgIGlmIChhZGJSZXRyaWVkKSB7XG4gICAgICAgICAgYWRiUmV0cmllZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNGdW5jKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUuY29kZSA9PT0gMCAmJiBlLnN0ZG91dCkge1xuICAgICAgICByZXR1cm4gZS5zdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzTnVsbChlLmNvZGUpKSB7XG4gICAgICAgIGUubWVzc2FnZSA9IGBFcnJvciBleGVjdXRpbmcgYWRiRXhlYy4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nLiBgICtcbiAgICAgICAgICBgVHJ5IHRvIGluY3JlYXNlIHRoZSAke29wdHMudGltZW91dH1tcyBhZGIgZXhlY3V0aW9uIHRpbWVvdXQgcmVwcmVzZW50ZWQgYnkgJyR7b3B0cy50aW1lb3V0Q2FwTmFtZX0nIGNhcGFiaWxpdHlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgIGBDb21tYW5kIG91dHB1dDogJHtlLnN0ZGVyciB8fCBlLnN0ZG91dCB8fCAnPGVtcHR5Pid9YDtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIGlmIChpc0V4ZWNMb2NrZWQpIHtcbiAgICBsb2cuZGVidWcoJ1dhaXRpbmcgdW50aWwgdGhlIG90aGVyIGV4Y2x1c2l2ZSBBREIgY29tbWFuZCBpcyBjb21wbGV0ZWQnKTtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKCgpID0+ICFpc0V4ZWNMb2NrZWQsIHtcbiAgICAgIHdhaXRNczogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBpbnRlcnZhbE1zOiAxMCxcbiAgICB9KTtcbiAgICBsb2cuZGVidWcoJ0NvbnRpbnVpbmcgd2l0aCB0aGUgY3VycmVudCBBREIgY29tbWFuZCcpO1xuICB9XG4gIGlmIChvcHRzLmV4Y2x1c2l2ZSkge1xuICAgIGlzRXhlY0xvY2tlZCA9IHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXhlY0Z1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob3B0cy5leGNsdXNpdmUpIHtcbiAgICAgIGlzRXhlY0xvY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaGVsbEV4ZWNPcHRpb25zXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRpbWVvdXRDYXBOYW1lIFthZGJFeGVjVGltZW91dF0gLSB0aGUgbmFtZSBvZiB0aGUgY29ycmVzcG9uZGluZyBBcHBpdW0ncyB0aW1lb3V0IGNhcGFiaWxpdHlcbiAqICh1c2VkIGluIHRoZSBlcnJvciBtZXNzYWdlcykuXG4gKiBAcHJvcGVydHkgez9udW1iZXJ9IHRpbWVvdXQgW2FkYkV4ZWNUaW1lb3V0XSAtIGNvbW1hbmQgZXhlY3V0aW9uIHRpbWVvdXQuXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBwcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIHJ1biB0aGUgZ2l2ZW4gY29tbWFuZCBhcyByb290LlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBvdXRwdXRGb3JtYXQgW3N0ZG91dF0gLSBXaGV0aGVyIHJlc3BvbnNlIHNob3VsZCBpbmNsdWRlIGZ1bGwgZXhlYyBvdXRwdXQgb3IganVzdCBzdGRvdXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvdGVudGlhbCB2YWx1ZXMgYXJlIGZ1bGwgb3Igc3Rkb3V0LlxuICpcbiAqIEFsbCBvdGhlciBwcm9wZXJ0aWVzIGFyZSB0aGUgc2FtZSBhcyBmb3IgYGV4ZWNgIGNhbGwgZnJvbSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqIG1vZHVsZVxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gY29tbWFuZCB1c2luZyBfYWRiIHNoZWxsXyBwcmVmaXguXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz58c3RyaW5nfSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycyBvciBhIHNpbmdsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0gez9TaGVsbEV4ZWNPcHRpb25zfSBvcHRzIFt7fV0gLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy5cbiAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn0gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2hlbGwgPSBhc3luYyBmdW5jdGlvbiBzaGVsbCAoY21kLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHByaXZpbGVnZWQsXG4gIH0gPSBvcHRzO1xuXG4gIGNvbnN0IGNtZEFyciA9IF8uaXNBcnJheShjbWQpID8gY21kIDogW2NtZF07XG4gIGNvbnN0IGZ1bGxDbWQgPSBbJ3NoZWxsJ107XG4gIGlmIChwcml2aWxlZ2VkKSB7XG4gICAgbG9nLmluZm8oYCdhZGIgc2hlbGwgJHt1dGlsLnF1b3RlKGNtZEFycil9JyByZXF1aXJlcyByb290IGFjY2Vzc2ApO1xuICAgIGlmIChhd2FpdCB0aGlzLmlzUm9vdCgpKSB7XG4gICAgICBsb2cuaW5mbygnVGhlIGRldmljZSBhbHJlYWR5IGhhZCByb290IGFjY2VzcycpO1xuICAgICAgZnVsbENtZC5wdXNoKC4uLmNtZEFycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGxDbWQucHVzaCgnc3UnLCAncm9vdCcsIHV0aWwucXVvdGUoY21kQXJyKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZ1bGxDbWQucHVzaCguLi5jbWRBcnIpO1xuICB9XG4gIHJldHVybiBhd2FpdCB0aGlzLmFkYkV4ZWMoZnVsbENtZCwgb3B0cyk7XG59O1xuXG5zeXN0ZW1DYWxsTWV0aG9kcy5jcmVhdGVTdWJQcm9jZXNzID0gZnVuY3Rpb24gY3JlYXRlU3ViUHJvY2VzcyAoYXJncyA9IFtdKSB7XG4gIC8vIGFkZCB0aGUgZGVmYXVsdCBhcmd1bWVudHNcbiAgYXJncyA9IFsuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsIC4uLmFyZ3NdO1xuICBsb2cuZGVidWcoYENyZWF0aW5nIEFEQiBzdWJwcm9jZXNzIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgcmV0dXJuIG5ldyBTdWJQcm9jZXNzKHRoaXMuZ2V0QWRiUGF0aCgpLCBhcmdzKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgYWRiIHBvcnQuXG4gKiBAdG9kbyBjYW4gcHJvYmFibHkgZGVwcmVjYXRlIHRoaXMgbm93IHRoYXQgdGhlIGxvZ2ljIGlzIGp1c3QgdG8gcmVhZCB0aGlzLmFkYlBvcnRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgYWRiIHBvcnQgbnVtYmVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJTZXJ2ZXJQb3J0ID0gZnVuY3Rpb24gZ2V0QWRiU2VydmVyUG9ydCAoKSB7XG4gIHJldHVybiB0aGlzLmFkYlBvcnQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgZnJvbSBfYWRiIGRldml2ZXNfIG91dHB1dC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRFbXVsYXRvclBvcnQgPSBhc3luYyBmdW5jdGlvbiBnZXRFbXVsYXRvclBvcnQgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgcnVubmluZyBlbXVsYXRvciBwb3J0Jyk7XG4gIGlmICh0aGlzLmVtdWxhdG9yUG9ydCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtdWxhdG9yUG9ydDtcbiAgfVxuICB0cnkge1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IHBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlc1swXS51ZGlkKTtcbiAgICBpZiAocG9ydCkge1xuICAgICAgcmV0dXJuIHBvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW11bGF0b3IgcG9ydCBub3QgZm91bmRgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRldmljZXMgY29ubmVjdGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBieSBwYXJzaW5nIGVtdWxhdG9yIG5hbWUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbVN0ciAtIEVtdWxhdG9yIG5hbWUgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59IEVpdGhlciB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZhbHNlXyBpZiBwb3J0IG51bWJlciBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nID0gZnVuY3Rpb24gZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyAoZW1TdHIpIHtcbiAgbGV0IHBvcnRQYXR0ZXJuID0gL2VtdWxhdG9yLShcXGQrKS87XG4gIGlmIChwb3J0UGF0dGVybi50ZXN0KGVtU3RyKSkge1xuICAgIHJldHVybiBwYXJzZUludChwb3J0UGF0dGVybi5leGVjKGVtU3RyKVsxXSwgMTApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBlbXVsYXRvcnMuXG4gKlxuICogQHBhcmFtIHs/Q29ubmVjdGVkRGV2aWNlc09wdGlvbnN9IG9wdHMgW3t9XSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFbXVsYXRvcnMgKG9wdHMgPSB7fSkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgY29ubmVjdGVkIGVtdWxhdG9ycycpO1xuICB0cnkge1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKG9wdHMpO1xuICAgIGxldCBlbXVsYXRvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgbGV0IHBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlLnVkaWQpO1xuICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgZGV2aWNlLnBvcnQgPSBwb3J0O1xuICAgICAgICBlbXVsYXRvcnMucHVzaChkZXZpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7dXRpbC5wbHVyYWxpemUoJ2VtdWxhdG9yJywgZW11bGF0b3JzLmxlbmd0aCwgdHJ1ZSl9IGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBlbXVsYXRvcnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IF9lbXVsYXRvclBvcnRfIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbVBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldEVtdWxhdG9yUG9ydCA9IGZ1bmN0aW9uIHNldEVtdWxhdG9yUG9ydCAoZW1Qb3J0KSB7XG4gIHRoaXMuZW11bGF0b3JQb3J0ID0gZW1Qb3J0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGN1cnJlbnQgZGV2aWNlIChfdGhpcy5jdXJEZXZpY2VJZF8pLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIFRoZSBkZXZpY2UgaWRlbnRpZmllci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlSWQgPSBmdW5jdGlvbiBzZXREZXZpY2VJZCAoZGV2aWNlSWQpIHtcbiAgbG9nLmRlYnVnKGBTZXR0aW5nIGRldmljZSBpZCB0byAke2RldmljZUlkfWApO1xuICB0aGlzLmN1ckRldmljZUlkID0gZGV2aWNlSWQ7XG4gIGxldCBhcmdzSGFzRGV2aWNlID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmluZGV4T2YoJy1zJyk7XG4gIGlmIChhcmdzSGFzRGV2aWNlICE9PSAtMSkge1xuICAgIC8vIHJlbW92ZSB0aGUgb2xkIGRldmljZSBpZCBmcm9tIHRoZSBhcmd1bWVudHNcbiAgICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3Muc3BsaWNlKGFyZ3NIYXNEZXZpY2UsIDIpO1xuICB9XG4gIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5wdXNoKCctcycsIGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0aGUgY3VycmVudCBkZXZpY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VPYmogLSBUaGUgZGV2aWNlIG9iamVjdCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZSA9IGZ1bmN0aW9uIHNldERldmljZSAoZGV2aWNlT2JqKSB7XG4gIGxldCBkZXZpY2VJZCA9IGRldmljZU9iai51ZGlkO1xuICBsZXQgZW1Qb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZUlkKTtcbiAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW1Qb3J0KTtcbiAgdGhpcy5zZXREZXZpY2VJZChkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKiAhISEgVGhpcyBtZXRob2QgaGFzIGEgc2lkZSBlZmZlY3QgLSBpdCBpbXBsaWNpdGx5IGNoYW5nZXMgdGhlXG4gKiBgZGV2aWNlSWRgIChvbmx5IGlmIEFWRCB3aXRoIGEgbWF0Y2hpbmcgbmFtZSBpcyBmb3VuZClcbiAqIGFuZCBgZW11bGF0b3JQb3J0YCBpbnN0YW5jZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gRW11bGF0b3IgbmFtZS5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRCA9IGFzeW5jIGZ1bmN0aW9uIGdldFJ1bm5pbmdBVkQgKGF2ZE5hbWUpIHtcbiAgbG9nLmRlYnVnKGBUcnlpbmcgdG8gZmluZCAnJHthdmROYW1lfScgZW11bGF0b3JgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBlbXVsYXRvcnMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZEVtdWxhdG9ycygpO1xuICAgIGZvciAoY29uc3QgZW11bGF0b3Igb2YgZW11bGF0b3JzKSB7XG4gICAgICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbXVsYXRvci5wb3J0KTtcbiAgICAgIGNvbnN0IHJ1bm5pbmdBVkROYW1lID0gYXdhaXQgdGhpcy5leGVjRW11Q29uc29sZUNvbW1hbmQoWydhdmQnLCAnbmFtZSddLCB7XG4gICAgICAgIHBvcnQ6IGVtdWxhdG9yLnBvcnQsXG4gICAgICAgIGV4ZWNUaW1lb3V0OiA1MDAwLFxuICAgICAgICBjb25uVGltZW91dDogMTAwMCxcbiAgICAgIH0pO1xuICAgICAgaWYgKF8udG9Mb3dlcihhdmROYW1lKSA9PT0gXy50b0xvd2VyKHJ1bm5pbmdBVkROYW1lLnRyaW0oKSkpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBGb3VuZCBlbXVsYXRvciAnJHthdmROYW1lfScgb24gcG9ydCAke2VtdWxhdG9yLnBvcnR9YCk7XG4gICAgICAgIHRoaXMuc2V0RGV2aWNlSWQoZW11bGF0b3IudWRpZCk7XG4gICAgICAgIHJldHVybiBlbXVsYXRvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGBFbXVsYXRvciAnJHthdmROYW1lfScgbm90IHJ1bm5pbmdgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gRW11bGF0b3IgbmFtZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzIwMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHdhaXQgdW50aWwgYXQgbGVhc3Qgb25lIHJ1bm5pbmcgQVZEIG9iamVjdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZGV0ZWN0ZWQuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gZGV2aWNlIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiB0aGUgdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIGdldFJ1bm5pbmdBVkRXaXRoUmV0cnkgKGF2ZE5hbWUsIHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lLnJlcGxhY2UoJ0AnLCAnJykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZGVidWcoZS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMTAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQgd2l0aCByZXRyeS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNodXRkb3duIGFsbCBydW5uaW5nIGVtdWxhdG9ycyBieSBraWxsaW5nIHRoZWlyIHByb2Nlc3Nlcy5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYga2lsbGluZyB0b29sIHJldHVybmVkIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsQWxsRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24ga2lsbEFsbEVtdWxhdG9ycyAoKSB7XG4gIGxldCBjbWQsIGFyZ3M7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBjbWQgPSAnVEFTS0tJTEwnO1xuICAgIGFyZ3MgPSBbJ1RBU0tLSUxMJywgJy9JTScsICdlbXVsYXRvci5leGUnXTtcbiAgfSBlbHNlIHtcbiAgICBjbWQgPSAnL3Vzci9iaW4va2lsbGFsbCc7XG4gICAgYXJncyA9IFsnLW0nLCAnZW11bGF0b3IqJ107XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKGNtZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGtpbGxpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBlbXVsYXRvciB3aXRoIHRoZSBnaXZlbiBuYW1lLiBObyBlcnJvclxuICogaXMgdGhyb3duIGlzIGdpdmVuIGF2ZCBkb2VzIG5vdCBleGlzdC9pcyBub3QgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZW11bGF0b3IgdG8gYmUga2lsbGVkLiBJZiBlbXB0eSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGVtdWxhdG9yIHdpbGwgYmUga2lsbGVkLlxuICogQHBhcmFtIHs/bnVtYmVyfSB0aW1lb3V0IFs2MDAwMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdGhyb3dpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gZXhjZXB0aW9uIGFib3V0IHVuc3VjY2Vzc2Z1bCBraWxsaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVtdWxhdG9yIHdhcyBraWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIGJ5IGtpbGxpbmcgdGhlIGVtdWxhdG9yXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxFbXVsYXRvciA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxFbXVsYXRvciAoYXZkTmFtZSA9IG51bGwsIHRpbWVvdXQgPSA2MDAwMCkge1xuICBpZiAodXRpbC5oYXNWYWx1ZShhdmROYW1lKSkge1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgJyR7YXZkTmFtZX0nYCk7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpO1xuICAgIGlmICghZGV2aWNlKSB7XG4gICAgICBsb2cuaW5mbyhgTm8gYXZkIHdpdGggbmFtZSAnJHthdmROYW1lfScgcnVubmluZy4gU2tpcHBpbmcga2lsbCBzdGVwLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBraWxsaW5nIHRoZSBjdXJyZW50IGF2ZFxuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgd2l0aCBpZCAnJHt0aGlzLmN1ckRldmljZUlkfSdgKTtcbiAgICBpZiAoIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpKSB7XG4gICAgICBsb2cuZGVidWcoYEVtdWxhdG9yIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nIG5vdCBjb25uZWN0ZWQuIFNraXBwaW5nIGtpbGwgc3RlcGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAna2lsbCddKTtcbiAgbG9nLmRlYnVnKGBXYWl0aW5nIHVwIHRvICR7dGltZW91dH1tcyB1bnRpbCB0aGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMga2lsbGVkYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXRpbC5oYXNWYWx1ZShhdmROYW1lKVxuICAgICAgICAgID8gIWF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKVxuICAgICAgICAgIDogIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dCxcbiAgICAgIGludGVydmFsTXM6IDIwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBlbXVsYXRvciAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBpcyBzdGlsbCBydW5uaW5nIGFmdGVyIGJlaW5nIGtpbGxlZCAke3RpbWVvdXR9bXMgYWdvYCk7XG4gIH1cbiAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBraWxsZWQgdGhlICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGVtdWxhdG9yYCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdmRMYXVuY2hPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBhcmdzIEFkZGl0aW9uYWwgZW11bGF0b3IgY29tbWFuZCBsaW5lIGFyZ3VtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGVudiBBZGRpdGlvbmFsIGVtdWxhdG9yIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGxhbmd1YWdlIEVtdWxhdG9yIHN5c3RlbSBsYW5ndWFnZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvdW50cnkgRW11bGF0b3Igc3lzdGVtIGNvdW50cnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXVuY2hUaW1lb3V0IFs2MDAwMF0gRW11bGF0b3Igc3RhcnR1cCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlYWR5VGltZW91dCBbNjAwMDBdIFRoZSBtYXhpbXVtIHBlcmlvZCBvZiB0aW1lIHRvIHdhaXQgdW50aWwgRW11bGF0b3JcbiAqIGlzIHJlYWR5IGZvciB1c2FnZSBpbiBtaWxsaXNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXRyeVRpbWVzIFsxXSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3RhcnR1cCByZXRyaWVzXG4gKi9cblxuLyoqXG4gKiBTdGFydCBhbiBlbXVsYXRvciB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIHdhaXQgdW50aWwgaXQgaXMgZnVsbHkgc3RhcnRlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGFuIGV4aXN0aW5nIGVtdWxhdG9yLlxuICogQHBhcmFtIHs/QXZkTGF1bmNoT3B0aW9uc30gb3B0c1xuICogQHJldHVybnMge1N1YlByb2Nlc3N9IEVtdWxhdG9yIHN1YnByb2Nlc3MgaW5zdGFuY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgZmFpbHMgdG8gc3RhcnQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5sYXVuY2hBVkQgPSBhc3luYyBmdW5jdGlvbiBsYXVuY2hBVkQgKGF2ZE5hbWUsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgYXJncyA9IFtdLFxuICAgIGVudiA9IHt9LFxuICAgIGxhbmd1YWdlLFxuICAgIGNvdW50cnksXG4gICAgbGF1bmNoVGltZW91dCA9IDYwMDAwLFxuICAgIHJlYWR5VGltZW91dCA9IDYwMDAwLFxuICAgIHJldHJ5VGltZXMgPSAxLFxuICB9ID0gb3B0cztcbiAgbG9nLmRlYnVnKGBMYXVuY2hpbmcgRW11bGF0b3Igd2l0aCBBVkQgJHthdmROYW1lfSwgbGF1bmNoVGltZW91dCBgICtcbiAgICAgICAgICAgIGAke2xhdW5jaFRpbWVvdXR9bXMgYW5kIHJlYWR5VGltZW91dCAke3JlYWR5VGltZW91dH1tc2ApO1xuICBjb25zdCBlbXVsYXRvckJpbmFyeVBhdGggPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoJ2VtdWxhdG9yJyk7XG4gIGlmIChhdmROYW1lWzBdID09PSAnQCcpIHtcbiAgICBhdmROYW1lID0gYXZkTmFtZS5zdWJzdHIoMSk7XG4gIH1cbiAgYXdhaXQgdGhpcy5jaGVja0F2ZEV4aXN0KGF2ZE5hbWUpO1xuXG4gIGNvbnN0IGxhdW5jaEFyZ3MgPSBbJy1hdmQnLCBhdmROYW1lXTtcbiAgbGF1bmNoQXJncy5wdXNoKC4uLih0b0F2ZExvY2FsZUFyZ3MobGFuZ3VhZ2UsIGNvdW50cnkpKSk7XG5cbiAgbGV0IGlzRGVsYXlBZGJGZWF0dXJlRW5hYmxlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5hbGxvd0RlbGF5QWRiKSB7XG4gICAgY29uc3Qge3JldmlzaW9ufSA9IGF3YWl0IHRoaXMuZ2V0RW11VmVyc2lvbkluZm8oKTtcbiAgICBpZiAocmV2aXNpb24gJiYgdXRpbC5jb21wYXJlVmVyc2lvbnMocmV2aXNpb24sICc+PScsICcyOS4wLjcnKSkge1xuICAgICAgLy8gaHR0cHM6Ly9hbmRyb2lkc3R1ZGlvLmdvb2dsZWJsb2cuY29tLzIwMTkvMDUvZW11bGF0b3ItMjkwNy1jYW5hcnkuaHRtbFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge3RhcmdldH0gPSBhd2FpdCB0aGlzLmdldEVtdUltYWdlUHJvcGVydGllcyhhdmROYW1lKTtcbiAgICAgICAgY29uc3QgYXBpTWF0Y2ggPSAvXFxkKy8uZXhlYyh0YXJnZXQpO1xuICAgICAgICAvLyBodHRwczovL2lzc3VldHJhY2tlci5nb29nbGUuY29tL2lzc3Vlcy8xNDI1MzMzNTVcbiAgICAgICAgaWYgKGFwaU1hdGNoICYmIHBhcnNlSW50KGFwaU1hdGNoWzBdLCAxMCkgPj0gTUlOX0RFTEFZX0FEQl9BUElfTEVWRUwpIHtcbiAgICAgICAgICBsYXVuY2hBcmdzLnB1c2goJy1kZWxheS1hZGInKTtcbiAgICAgICAgICBpc0RlbGF5QWRiRmVhdHVyZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGFjdHVhbCBpbWFnZSBBUEkgdmVyc2lvbiBpcyBiZWxvdyAke01JTl9ERUxBWV9BREJfQVBJX0xFVkVMfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5pbmZvKGBUaGUgLWRlbGF5LWFkYiBlbXVsYXRvciBzdGFydHVwIGRldGVjdGlvbiBmZWF0dXJlIHdpbGwgbm90IGJlIGVuYWJsZWQuIGAgK1xuICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxvZy5pbmZvKCdUaGUgLWRlbGF5LWFkYiBlbXVsYXRvciBzdGFydHVwIGRldGVjdGlvbiBmZWF0dXJlIGhhcyBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQnKTtcbiAgfVxuXG4gIGlmICghXy5pc0VtcHR5KGFyZ3MpKSB7XG4gICAgbGF1bmNoQXJncy5wdXNoKC4uLihfLmlzQXJyYXkoYXJncykgPyBhcmdzIDogdXRpbC5zaGVsbFBhcnNlKGAke2FyZ3N9YCkpKTtcbiAgfVxuXG4gIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHtlbXVsYXRvckJpbmFyeVBhdGh9JyB3aXRoIGFyZ3M6ICR7dXRpbC5xdW90ZShsYXVuY2hBcmdzKX1gKTtcbiAgaWYgKCFfLmlzRW1wdHkoZW52KSkge1xuICAgIGxvZy5kZWJ1ZyhgQ3VzdG9taXplZCBlbXVsYXRvciBlbnZpcm9ubWVudDogJHtKU09OLnN0cmluZ2lmeShlbnYpfWApO1xuICB9XG4gIGNvbnN0IHByb2MgPSBuZXcgU3ViUHJvY2VzcyhlbXVsYXRvckJpbmFyeVBhdGgsIGxhdW5jaEFyZ3MsIHtcbiAgICBlbnY6IE9iamVjdC5hc3NpZ24oe30sIHByb2Nlc3MuZW52LCBlbnYpLFxuICB9KTtcbiAgYXdhaXQgcHJvYy5zdGFydCgwKTtcbiAgcHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiAoc3Rkb3V0IHx8IHN0ZGVyciB8fCAnJykuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKSkge1xuICAgICAgbG9nLmluZm8oYFtBVkQgT1VUUFVUXSAke2xpbmV9YCk7XG4gICAgfVxuICB9KTtcbiAgcHJvYy5vbignZGllJywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgIGxvZy53YXJuKGBFbXVsYXRvciBhdmQgJHthdmROYW1lfSBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX0ke3NpZ25hbCA/IGAsIHNpZ25hbCAke3NpZ25hbH1gIDogJyd9YCk7XG4gIH0pO1xuICBhd2FpdCByZXRyeShyZXRyeVRpbWVzLCBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkoYXZkTmFtZSwgbGF1bmNoVGltZW91dCkpO1xuICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgZGV2aWNlSWQgYWxyZWFkeSBhc3NpZ25lZFxuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICBpZiAoaXNEZWxheUFkYkZlYXR1cmVFbmFibGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3dhaXQtZm9yLWRldmljZSddLCB7dGltZW91dDogcmVhZHlUaW1lb3V0fSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHthdmROYW1lfScgRW11bGF0b3IgaGFzIGZhaWxlZCB0byBib290OiAke2Uuc3RkZXJyIHx8IGUubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShyZWFkeVRpbWVvdXQgLSB0aW1lci5nZXREdXJhdGlvbigpLmFzTWlsbGlTZWNvbmRzKTtcbiAgcmV0dXJuIHByb2M7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJpbmFyeVZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7U2VtVmVyfSB2ZXJzaW9uIC0gVGhlIEFEQiBiaW5hcnkgdmVyc2lvbiBudW1iZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBidWlsZCAtIFRoZSBBREIgYmluYXJ5IGJ1aWxkIG51bWJlclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQnJpZGdlVmVyc2lvblxuICogQHByb3BlcnR5IHtTZW1WZXJ9IHZlcnNpb24gLSBUaGUgQW5kcm9pZCBEZWJ1ZyBCcmlkZ2UgdmVyc2lvbiBudW1iZXJcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7P0JpbmFyeVZlcnNpb259IGJpbmFyeSBUaGlzIHZlcnNpb24gbnVtYmVyIG1pZ2h0IG5vdCBiZVxuICogYmUgcHJlc2VudCBmb3Igb2xkZXIgQURCIHJlbGVhc2VzLlxuICogQHByb3BlcnR5IHtCcmlkZ2VWZXJzaW9ufSBicmlkZ2VcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgYWRiIHZlcnNpb24uIFRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgY2FjaGVkLlxuICpcbiAqIEByZXR1cm4ge1ZlcnNpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiBiaW5hcnkgdmVyc2lvbi5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0VmVyc2lvbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiBnZXRWZXJzaW9uICgpIHtcbiAgbGV0IHN0ZG91dDtcbiAgdHJ5IHtcbiAgICBzdGRvdXQgPSBhd2FpdCB0aGlzLmFkYkV4ZWMoJ3ZlcnNpb24nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBhZGIgdmVyc2lvbjogJHtlLnN0ZGVyciB8fCBlLm1lc3NhZ2V9YCk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYmluYXJ5VmVyc2lvbk1hdGNoID0gQklOQVJZX1ZFUlNJT05fUEFUVEVSTi5leGVjKHN0ZG91dCk7XG4gIGlmIChiaW5hcnlWZXJzaW9uTWF0Y2gpIHtcbiAgICByZXN1bHQuYmluYXJ5ID0ge1xuICAgICAgdmVyc2lvbjogc2VtdmVyLmNvZXJjZShiaW5hcnlWZXJzaW9uTWF0Y2hbMV0pLFxuICAgICAgYnVpbGQ6IHBhcnNlSW50KGJpbmFyeVZlcnNpb25NYXRjaFsyXSwgMTApLFxuICAgIH07XG4gIH1cbiAgY29uc3QgYnJpZGdlVmVyc2lvbk1hdGNoID0gQlJJREdFX1ZFUlNJT05fUEFUVEVSTi5leGVjKHN0ZG91dCk7XG4gIGlmIChicmlkZ2VWZXJzaW9uTWF0Y2gpIHtcbiAgICByZXN1bHQuYnJpZGdlID0ge1xuICAgICAgdmVyc2lvbjogc2VtdmVyLmNvZXJjZShicmlkZ2VWZXJzaW9uTWF0Y2hbMV0pLFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGVtdWxhdG9yIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRW11bGF0b3JSZWFkeSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JFbXVsYXRvclJlYWR5ICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBpZiAoYXdhaXQgdGhpcy5nZXRBcGlMZXZlbCgpID49IDMxKSB7XG4gICAgbGV0IHJlYXNvbjtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVhc29uID0gYXdhaXQgdGhpcy5zaGVsbChbJ2NtZCcsICdyZWJvb3RfcmVhZGluZXNzJywgJ2NoZWNrLXN1YnN5c3RlbXMtc3RhdGUnLCAnLS1saXN0LWJsb2NraW5nJ10pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9pc3N1ZXMvMTg3MTdcbiAgICAgICAgICByZWFzb24gPSBlcnIuc3Rkb3V0IHx8IGVyci5zdGRlcnI7XG4gICAgICAgICAgaWYgKCFfLmluY2x1ZGVzKHJlYXNvbiwgU1VCU1lTVEVNX1NUQVRFX09LKSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKGBXYWl0aW5nIGZvciBlbXVsYXRvciBzdGFydHVwLiBJbnRlcm1lZGlhdGUgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLmluY2x1ZGVzKHJlYXNvbiwgU1VCU1lTVEVNX1NUQVRFX09LKTtcbiAgICAgIH0sIHtcbiAgICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICAgIGludGVydmFsTXM6IDEwMDAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gJHt0aW1lb3V0TXN9bXMke3JlYXNvbiA/ICgnLiBSZWFzb246ICcgKyByZWFzb24pIDogJyd9YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVxdWlyZWRTZXJ2aWNlc1JlID0gUkVRVUlSRURfU0VSVklDRVMubWFwKChuYW1lKSA9PiBuZXcgUmVnRXhwKGBcXFxcYiR7bmFtZX06YCkpO1xuICBsZXQgc2VydmljZXM7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXJ2aWNlcyA9IGF3YWl0IHRoaXMuc2hlbGwoWydzZXJ2aWNlJywgJ2xpc3QnXSk7XG4gICAgICAgIHJldHVybiByZXF1aXJlZFNlcnZpY2VzUmUuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChzZXJ2aWNlcykpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgV2FpdGluZyBmb3IgZW11bGF0b3Igc3RhcnR1cC4gSW50ZXJtZWRpYXRlIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAzMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlcnZpY2VzKSB7XG4gICAgICBsb2cuZGVidWcoYFJlY2VudGx5IGxpc3RlZCBzZXJ2aWNlczpcXG4ke3NlcnZpY2VzfWApO1xuICAgIH1cbiAgICBjb25zdCBtaXNzaW5nU2VydmljZXMgPSBfLnppcChSRVFVSVJFRF9TRVJWSUNFUywgcmVxdWlyZWRTZXJ2aWNlc1JlKVxuICAgICAgLmZpbHRlcigoWywgcGF0dGVybl0pID0+ICFwYXR0ZXJuLnRlc3Qoc2VydmljZXMpKVxuICAgICAgLm1hcCgoW25hbWVdKSA9PiBuYW1lKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIGlzIG5vdCByZWFkeSB3aXRoaW4gJHt0aW1lb3V0TXN9bXMgYCArXG4gICAgICBgKCR7bWlzc2luZ1NlcnZpY2VzfSBzZXJ2aWNlJHttaXNzaW5nU2VydmljZXMubGVuZ3RoID09PSAxID8gJyBpcycgOiAncyBhcmUnfSBub3QgcnVubmluZylgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBkZXZpY2UgaXMgcmVhZHkgdG8gYWNjZXB0IGZ1cnRoZXIgY29tbWFuZHMgKGJvb3RpbmcgY29tcGxldGVkKS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0IFszMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckRldmljZSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JEZXZpY2UgKGFwcERldmljZVJlYWR5VGltZW91dCA9IDMwKSB7XG4gIHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gYXBwRGV2aWNlUmVhZHlUaW1lb3V0O1xuICBjb25zdCByZXRyaWVzID0gMztcbiAgY29uc3QgdGltZW91dCA9IHBhcnNlSW50KHRoaXMuYXBwRGV2aWNlUmVhZHlUaW1lb3V0LCAxMCkgKiAxMDAwIC8gcmV0cmllcztcbiAgYXdhaXQgcmV0cnkocmV0cmllcywgYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoJ3dhaXQtZm9yLWRldmljZScsIHt0aW1lb3V0fSk7XG4gICAgICBhd2FpdCB0aGlzLnBpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHJlYm9vdCAocmV0cmllcyA9IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTKSB7XG4gIC8vIEdldCByb290IGFjY2VzcyBzbyB3ZSBjYW4gcnVuIHRoZSBuZXh0IHNoZWxsIGNvbW1hbmRzIHdoaWNoIHJlcXVpcmUgcm9vdCBhY2Nlc3NcbiAgY29uc3QgeyB3YXNBbHJlYWR5Um9vdGVkIH0gPSBhd2FpdCB0aGlzLnJvb3QoKTtcbiAgdHJ5IHtcbiAgICAvLyBTdG9wIGFuZCByZS1zdGFydCB0aGUgZGV2aWNlXG4gICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSk7XG4gICAgYXdhaXQgQi5kZWxheSgyMDAwKTsgLy8gbGV0IHRoZSBlbXUgZmluaXNoIHN0b3BwaW5nO1xuICAgIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDAsIHtcbiAgICAgIHByaXZpbGVnZWQ6IGZhbHNlIC8vIG5vIG5lZWQgdG8gc2V0IHByaXZpbGVnZWQgdHJ1ZSBiZWNhdXNlIGRldmljZSBhbHJlYWR5IHJvb3RlZFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdGFydCddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IHttZXNzYWdlfSA9IGU7XG5cbiAgICAvLyBwcm92aWRlIGEgaGVscGZ1bCBlcnJvciBtZXNzYWdlIGlmIHRoZSByZWFzb24gcmVib290IGZhaWxlZCB3YXMgYmVjYXVzZSBBREIgY291bGRuJ3QgZ2FpbiByb290IGFjY2Vzc1xuICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdtdXN0IGJlIHJvb3QnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVib290IGRldmljZS4gUmVib290aW5nIHJlcXVpcmVzIHJvb3QgYWNjZXNzIGFuZCBgICtcbiAgICAgICAgYGF0dGVtcHQgdG8gZ2V0IHJvb3QgYWNjZXNzIG9uIGRldmljZSBmYWlsZWQgd2l0aCBlcnJvcjogJyR7bWVzc2FnZX0nYCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gUmV0dXJuIHJvb3Qgc3RhdGUgdG8gd2hhdCBpdCB3YXMgYmVmb3JlXG4gICAgaWYgKCF3YXNBbHJlYWR5Um9vdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLnVucm9vdCgpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aW1lciA9IG5ldyB0aW1pbmcuVGltZXIoKS5zdGFydCgpO1xuICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICBpZiAoKGF3YWl0IHRoaXMuZ2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcpKSA9PT0gJzEnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlIHN0YWNrIHRyYWNlLCBzbyBubyBsb2cuZXJyb3JBbmRUaHJvd1xuICAgIGNvbnN0IG1zZyA9IGBSZWJvb3QgaXMgbm90IGNvbXBsZXRlZCBhZnRlciAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNNaWxsaVNlY29uZHMudG9GaXhlZCgwKX1tc2A7XG4gICAgbG9nLmRlYnVnKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSByb290UmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzU3VjY2Vzc2Z1bCBUcnVlIGlmIHRoZSBjYWxsIHRvIHJvb3QvdW5yb290IHdhcyBzdWNjZXNzZnVsXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdhc0FscmVhZHlSb290ZWQgVHJ1ZSBpZiB0aGUgZGV2aWNlIHdhcyBhbHJlYWR5IHJvb3RlZFxuICovXG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgcm9vdCBwcml2aWxlZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBpc0VsZXZhdGVkIC0gU2hvdWxkIHdlIGVsZXZhdGUgdG8gdG8gcm9vdCBvciB1bnJvb3Q/IChkZWZhdWx0IHRydWUpXG4gKiBAcmV0dXJuIHtyb290UmVzdWx0fVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5jaGFuZ2VVc2VyUHJpdmlsZWdlcyA9IGFzeW5jIGZ1bmN0aW9uIGNoYW5nZVVzZXJQcml2aWxlZ2VzIChpc0VsZXZhdGVkKSB7XG4gIGNvbnN0IGNtZCA9IGlzRWxldmF0ZWQgPyAncm9vdCcgOiAndW5yb290JztcblxuICBjb25zdCByZXRyeUlmT2ZmbGluZSA9IGFzeW5jIChjbWRGdW5jKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjbWRGdW5jKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBDaGVjayB0aGUgb3V0cHV0IG9mIHRoZSBzdGRFcnIgdG8gc2VlIGlmIHRoZXJlJ3MgYW55IGNsdWVzIHRoYXQgc2hvdyB0aGF0IHRoZSBkZXZpY2Ugd2VudCBvZmZsaW5lXG4gICAgICAvLyBhbmQgaWYgaXQgZGlkIGdvIG9mZmxpbmUsIHJlc3RhcnQgQURCXG4gICAgICBpZiAoWydjbG9zZWQnLCAnZGV2aWNlIG9mZmxpbmUnLCAndGltZW91dCBleHBpcmVkJ11cbiAgICAgICAgICAuc29tZSgoeCkgPT4gKGVyci5zdGRlcnIgfHwgJycpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoeCkpKSB7XG4gICAgICAgIGxvZy53YXJuKGBBdHRlbXB0IHRvICR7Y21kfSBjYXVzZWQgQURCIHRvIHRoaW5rIHRoZSBkZXZpY2Ugd2VudCBvZmZsaW5lYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSBjYXRjaCAoaWduKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGNtZEZ1bmMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gSWYgaXQncyBhbHJlYWR5IHJvb3RlZCwgb3VyIGpvYiBpcyBkb25lLiBObyBuZWVkIHRvIHJvb3QgaXQgYWdhaW4uXG4gIGNvbnN0IGlzUm9vdCA9IGF3YWl0IHJldHJ5SWZPZmZsaW5lKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuaXNSb290KCkpO1xuICBpZiAoKGlzUm9vdCAmJiBpc0VsZXZhdGVkKSB8fCAoIWlzUm9vdCAmJiAhaXNFbGV2YXRlZCkpIHtcbiAgICByZXR1cm4ge2lzU3VjY2Vzc2Z1bDogdHJ1ZSwgd2FzQWxyZWFkeVJvb3RlZDogaXNSb290fTtcbiAgfVxuXG4gIGxldCB3YXNBbHJlYWR5Um9vdGVkID0gaXNSb290O1xuICB0cnkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgcmV0cnlJZk9mZmxpbmUoYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5hZGJFeGVjKFtjbWRdKSk7XG4gICAgbG9nLmRlYnVnKHN0ZG91dCk7XG5cbiAgICAvLyBvbiByZWFsIGRldmljZXMgaW4gc29tZSBzaXR1YXRpb25zIHdlIGdldCBhbiBlcnJvciBpbiB0aGUgc3Rkb3V0XG4gICAgaWYgKHN0ZG91dCkge1xuICAgICAgaWYgKHN0ZG91dC5pbmNsdWRlcygnYWRiZCBjYW5ub3QgcnVuIGFzIHJvb3QnKSkge1xuICAgICAgICByZXR1cm4ge2lzU3VjY2Vzc2Z1bDogZmFsc2UsIHdhc0FscmVhZHlSb290ZWR9O1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIGRldmljZSB3YXMgYWxyZWFkeSByb290ZWQsIHJldHVybiB0aGF0IGluIHRoZSByZXN1bHRcbiAgICAgIGlmIChzdGRvdXQuaW5jbHVkZXMoJ2FscmVhZHkgcnVubmluZyBhcyByb290JykpIHtcbiAgICAgICAgd2FzQWxyZWFkeVJvb3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiB0cnVlLCB3YXNBbHJlYWR5Um9vdGVkfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3Qge3N0ZGVyciA9ICcnLCBtZXNzYWdlfSA9IGVycjtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvICR7Y21kfSBhZGIgZGFlbW9uLiBPcmlnaW5hbCBlcnJvcjogJyR7bWVzc2FnZX0nLiBTdGRlcnI6ICcke3N0ZGVycn0nLiBDb250aW51aW5nLmApO1xuICAgIHJldHVybiB7aXNTdWNjZXNzZnVsOiBmYWxzZSwgd2FzQWxyZWFkeVJvb3RlZH07XG4gIH1cbn07XG5cbi8qKlxuICogU3dpdGNoIGFkYiBzZXJ2ZXIgdG8gcm9vdCBtb2RlXG4gKiBAcmV0dXJuIHtyb290UmVzdWx0fVxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gcm9vdCAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoYW5nZVVzZXJQcml2aWxlZ2VzKHRydWUpO1xufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge3Jvb3RSZXN1bHR9XG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHVucm9vdCAoKSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoYW5nZVVzZXJQcml2aWxlZ2VzKGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlciBpcyByb290XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyByb290XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGlkZW50aWZ5aW5nXG4gKiB0aGUgdXNlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNSb290ID0gYXN5bmMgZnVuY3Rpb24gaXNSb290ICgpIHtcbiAgcmV0dXJuIChhd2FpdCB0aGlzLnNoZWxsKFsnd2hvYW1pJ10pKS50cmltKCkgPT09ICdyb290Jztcbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSByZW1vdGUgcGF0aCBleGlzdHMgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHZlcmlmeS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzIChyZW1vdGVQYXRoKSB7XG4gIGNvbnN0IHBhc3NGbGFnID0gJ19fUEFTU19fJztcbiAgY29uc3QgY2hlY2tDbWQgPSBgWyAtZSAnJHtyZW1vdGVQYXRoLnJlcGxhY2UoLycvZywgYFxcXFwnYCl9JyBdICYmIGVjaG8gJHtwYXNzRmxhZ31gO1xuICB0cnkge1xuICAgIHJldHVybiBfLmluY2x1ZGVzKGF3YWl0IHRoaXMuc2hlbGwoW2NoZWNrQ21kXSksIHBhc3NGbGFnKTtcbiAgfSBjYXRjaCAoaWduKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gbHMgKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIGxpbmVzLm1hcCgobCkgPT4gbC50cmltKCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuZmlsdGVyKChsKSA9PiBsLmluZGV4T2YoJ05vIHN1Y2ggZmlsZScpID09PSAtMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHBhcnRpY3VsYXIgZmlsZSBsb2NhdGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB0aGUgZmlsZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRmlsZSBzaXplIGluIGJ5dGVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBmaWxlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlU2l6ZSA9IGFzeW5jIGZ1bmN0aW9uIGZpbGVTaXplIChyZW1vdGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgsIFsnLWxhJ10pO1xuICAgIGlmIChmaWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIHBhdGggaXMgbm90IGEgZmlsZWApO1xuICAgIH1cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL2ZPczRQNC84XG4gICAgY29uc3QgbWF0Y2ggPSAvW3J3eHNTdFRcXC0rXXsxMH1bXFxzXFxkXSpcXHNbXlxcc10rXFxzK1teXFxzXStcXHMrKFxcZCspLy5leGVjKGZpbGVzWzBdKTtcbiAgICBpZiAoIW1hdGNoIHx8IF8uaXNOYU4ocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHNpemUgZnJvbSBsaXN0IG91dHB1dDogJyR7ZmlsZXNbMF19J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGZpbGUgc2l6ZSBmb3IgJyR7cmVtb3RlUGF0aH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbGxzIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBvbiBhIHJvb3RlZCByZWFsIGRldmljZSBvclxuICogYW4gZW11bGF0b3IuIFRoZSBlbXVsYXRvciBtdXN0IGJlIGV4ZWN1dGVkIHdpdGggYC13cml0YWJsZS1zeXN0ZW1gXG4gKiBjb21tYW5kIGxpbmUgb3B0aW9uIGFuZCBhZGIgZGFlbW9uIHNob3VsZCBiZSBydW5uaW5nIGluIHJvb3RcbiAqIG1vZGUgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmsgcHJvcGVybHkuIFRoZSBtZXRob2QgYWxzbyByZXF1aXJlc1xuICogb3BlbnNzbCB0b29sIHRvIGJlIGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtLlxuICogUmVhZCBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9pc3N1ZXMvMTA5NjRcbiAqIGZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0b3BpY1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaW5zdGFsbGluZyB0aGUgY2VydGlmaWNhdGVcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxNaXRtQ2VydGlmaWNhdGUgKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShzcmNDZXJ0LCBjZXJ0KTtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgc3JjQ2VydF0pO1xuICAgIGNvbnN0IGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgICBsb2cuZGVidWcoYEdvdCBjZXJ0aWZpY2F0ZSBoYXNoOiAke2NlcnRIYXNofWApO1xuICAgIGxvZy5kZWJ1ZygnUHJlcGFyaW5nIGNlcnRpZmljYXRlIGNvbnRlbnQnKTtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctaW4nLCBzcmNDZXJ0XSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGxldCBkc3RDZXJ0Q29udGVudCA9IHN0ZG91dDtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsXG4gICAgICAnLWluJywgc3JjQ2VydCxcbiAgICAgICctdGV4dCcsXG4gICAgICAnLWZpbmdlcnByaW50JyxcbiAgICAgICctbm9vdXQnXSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGRzdENlcnRDb250ZW50ID0gQnVmZmVyLmNvbmNhdChbZHN0Q2VydENvbnRlbnQsIHN0ZG91dF0pO1xuICAgIGNvbnN0IGRzdENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0Q2VydCwgZHN0Q2VydENvbnRlbnQpO1xuICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyAvc3lzdGVtIGluIHJ3IG1vZGUnKTtcbiAgICAvLyBTb21ldGltZXMgZW11bGF0b3IgcmVib290IGlzIHN0aWxsIG5vdCBmdWxseSBmaW5pc2hlZCBvbiB0aGlzIHN0YWdlLCBzbyByZXRyeVxuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoNSwgMjAwMCwgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5hZGJFeGVjKFsncmVtb3VudCddKSk7XG4gICAgbG9nLmRlYnVnKGBVcGxvYWRpbmcgdGhlIGdlbmVyYXRlZCBjZXJ0aWZpY2F0ZSBmcm9tICcke2RzdENlcnR9JyB0byAnJHtDRVJUU19ST09UfSdgKTtcbiAgICBhd2FpdCB0aGlzLnB1c2goZHN0Q2VydCwgQ0VSVFNfUk9PVCk7XG4gICAgbG9nLmRlYnVnKCdSZW1vdW50aW5nIC9zeXN0ZW0gdG8gY29uZmlybSBjaGFuZ2VzJyk7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsncmVtb3VudCddKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5qZWN0IHRoZSBjdXN0b20gY2VydGlmaWNhdGUuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYERvIHlvdSBoYXZlIHJvb3QgcGVybWlzc2lvbnMgb24gdGhlIGRldmljZT8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZpZXMgaWYgdGhlIGdpdmVuIHJvb3QgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgb24gdGhlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNoZWNraW5nIHRoZSBjZXJ0aWZpY2F0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkID0gYXN5bmMgZnVuY3Rpb24gaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQgKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGxldCBjZXJ0SGFzaDtcbiAgdHJ5IHtcbiAgICBjb25zdCB0bXBDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsICdzb3VyY2UuY2VyJyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRtcENlcnQsIGNlcnQpO1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHRtcENlcnRdKTtcbiAgICBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJldHJpZXZlIHRoZSBjZXJ0aWZpY2F0ZSBoYXNoLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucG9zaXgucmVzb2x2ZShDRVJUU19ST09ULCBgJHtjZXJ0SGFzaH0uMGApO1xuICBsb2cuZGVidWcoYENoZWNraW5nIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZCBhdCAnJHtkc3RQYXRofSdgKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZUV4aXN0cyhkc3RQYXRoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN5c3RlbUNhbGxNZXRob2RzO1xuZXhwb3J0IHsgREVGQVVMVF9BREJfRVhFQ19USU1FT1VULCBnZXRBbmRyb2lkQmluYXJ5UGF0aCB9O1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFBQSxLQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxPQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxTQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxRQUFBLEdBQUFILE9BQUE7QUFDQSxJQUFBSSxRQUFBLEdBQUFKLE9BQUE7QUFJQSxJQUFBSyxhQUFBLEdBQUFMLE9BQUE7QUFDQSxJQUFBTSxTQUFBLEdBQUFOLE9BQUE7QUFDQSxJQUFBTyxPQUFBLEdBQUFSLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBUSxPQUFBLEdBQUFULHNCQUFBLENBQUFDLE9BQUE7QUFHQSxJQUFJUyxpQkFBaUIsR0FBRyxDQUFDLENBQUM7QUFFMUIsTUFBTUMsMEJBQTBCLEdBQUcsRUFBRTtBQUNyQyxNQUFNQyxxQkFBcUIsR0FBRyxzQkFBc0I7QUFDcEQsTUFBTUMsd0JBQXdCLEdBQUcsQ0FDL0IsK0JBQStCLEVBQy9CLGtDQUFrQyxFQUNsQyxpQ0FBaUMsQ0FDbEM7QUFDRCxNQUFNQyxzQkFBc0IsR0FBRywwQkFBMEI7QUFDekQsTUFBTUMsc0JBQXNCLEdBQUcseUNBQXlDO0FBQ3hFLE1BQU1DLFVBQVUsR0FBRyw4QkFBOEI7QUFDakQsTUFBTUMsZ0JBQWdCLEdBQUcsQ0FDdkIsZ0JBQWdCLEVBQ2hCLFVBQVUsRUFDVixDQUFDLGVBQWUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLEVBQ2xDLE9BQU8sRUFDUCxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsRUFDaEIsR0FB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